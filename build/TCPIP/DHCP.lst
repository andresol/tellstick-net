     1: /*********************************************************************
     2: *
     3: *       Dynamic Host Configuration Protocol (DHCP) Client
     4: *       Module for Microchip TCP/IP Stack
     5: *        -Provides automatic IP address, subnet mask, gateway address, 
     6: *         DNS server address, and other configuration parameters on DHCP 
     7: *         enabled networks.
     8: *        -Reference: RFC 2131, 2132
     9: *
    10: *********************************************************************
    11: * FileName:             DHCP.c
    12: * Dependencies: UDP
    13: * Processor:    PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
    14: * Compiler:             Microchip C32 v1.05 or higher
    15: *                               Microchip C30 v3.12 or higher
    16: *                               Microchip C18 v3.30 or higher
    17: *                               HI-TECH PICC-18 PRO 9.63PL2 or higher
    18: * Company:              Microchip Technology, Inc.
    19: *
    20: * Software License Agreement
    21: *
    22: * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
    23: * reserved.
    24: *
    25: * Microchip licenses to you the right to use, modify, copy, and
    26: * distribute:
    27: * (i)  the Software when embedded on a Microchip microcontroller or
    28: *      digital signal controller product ("Device") which is
    29: *      integrated into Licensee's product; or
    30: * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
    31: *               ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
    32: *               used in conjunction with a Microchip ethernet controller for
    33: *               the sole purpose of interfacing with the ethernet controller.
    34: *
    35: * You should refer to the license agreement accompanying this
    36: * Software for additional information regarding your rights and
    37: * obligations.
    38: *
    39: * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
    40: * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
    41: * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
    42: * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
    43: * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
    44: * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
    45: * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
    46: * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
    47: * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
    48: * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
    49: * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
    50: *
    51: *
    52: * Author               Date    Comment
    53: *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    54: * Nilesh Rajbharti     3/21/01  Original        (Rev 1.0)
    55: * Nilesh Rajbharti     7/10/02  Explicitly initialized tempIPAddress
    56: *                                               (Rev 2.11)
    57: * Nilesh Rajbharti     5/16/03 Increased DHCP_TIMEOUT to 2 seconds.
    58: * Nilesh Rajbharti     5/16/03 Fixed SM_DHCP_BROADCAST logic
    59: *                              where UDPPut was called before setting
    60: *                              active socket.
    61: * Robert Sloan         5/29/03 Improved DHCP State machine to handle
    62: *                              NAK and renew existing IP address.
    63: * Nilesh Rajbharti     8/15/03 Modified _DHCPRecieve() to check for
    64: *                              chaddr field before accpting the packet.
    65: *                              Fixed DHCPTask() where it would not
    66: *                              reply to first OFFER.
    67: * Nilesh Rajbharti     3/1/04  Used tickDiff in DHCPTask() "bind"
    68: *                              state to adjust for irregular TICK_SECOND
    69: *                              Without this logic, actual lease time count
    70: *                              down may be incorrect.
    71: * Howard Schlunder              5/11/06 Fixed tickDiff usage, reducing 
    72: *                                                               accumulated timing error.  Fixed DHCP 
    73: *                                                               state machine requesting IP 0.0.0.0 
    74: *                                                               after lease expiration.
    75: * Howard Schlunder              6/01/06 Added DHCPFlags.bits.bOfferReceived flag to 
    76: *                                                               allow operation on networks with multiple
    77: *                                                               DHCP servers offering multiple addresses
    78: * Howard Schlunder              8/01/06 Added DNS server option to DHCP request, 
    79: *                                                               untested Host Name option to DHCP request
    80: * Howard Schlunder              1/09/06 Fixed a DHCP renewal not renewing lease time bug
    81: * Howard Schlunder              3/16/07 Rewrote DHCP state machine
    82: ********************************************************************/
    83: #define __DHCP_C
    84: 
    85: #include "TCPIPConfig.h"
    86: 
    87: #if defined(STACK_USE_DHCP_CLIENT)
    88: 
    89: #include "TCPIP Stack/TCPIP.h"
    90: 
    91: // Defines how long to wait before a DHCP request times out
    92: #define DHCP_DISCOVERY_TIMEOUT                  (2ul*TICK_SECOND)
    93: #define DHCP_REQUEST_TIMEOUT                            (15ul*TICK_SECOND)
    94: 
    95: // Unique variables per interface
    96: typedef struct
    97: {
    98:         UDP_SOCKET                      hDHCPSocket;    // Handle to DHCP client socket
    99:         SM_DHCP                         smState;                // DHCP client state machine variable
   100:         union
   101:         {
   102:             struct
   103:             {
   104:                 unsigned char bIsBound : 1;                             // Whether or not DHCP is currently bound
   105:                 unsigned char bEvent : 1;                               // Indicates to an external module that the DHCP client has been reset, has obtained new parameters via the DHCP client, or has refreshed a lease on existing ones
   106:                 unsigned char bOfferReceived : 1;               // Whether or not an offer has been received
   107:                         unsigned char bDHCPServerDetected : 1;  // Indicates if a DCHP server has been detected
   108:                         unsigned char bUseUnicastMode : 1;              // Indicates if the 
   109:             } bits;
   110:             BYTE val;
   111:         } flags;
   112:         DWORD                           dwTimer;                // Tick timer value used for triggering future events after a certain wait period.
   113:         DWORD                           dwSecs;         // The secs value in DHCP requests
   114:         DWORD                           dwLeaseTime;    // DHCP lease time remaining, in seconds
   115:         DWORD                           dwServerID;             // DHCP Server ID cache
   116:         IP_ADDR                         tempIPAddress;  // Temporary IP address to use when no DHCP lease
   117:         IP_ADDR                         tempGateway;    // Temporary gateway to use when no DHCP lease
   118:         IP_ADDR                         tempMask;               // Temporary mask to use when no DHCP lease
   119:         #if defined(STACK_USE_DNS)
   120:         IP_ADDR                         tempDNS;                // Temporary primary DNS server
   121:         IP_ADDR                         tempDNS2;               // Temporary secondary DNS server
   122:         #endif  
   123:         // Indicates which DHCP values are currently valid
   124:         union
   125:         {
   126:                 struct
   127:                 {
   128:                         char IPAddress:1;       // Leased IP address is valid
   129:                         char Gateway:1;         // Gateway address is valid
   130:                         char Mask:1;            // Subnet mask is valid
   131:                         char DNS:1;                     // Primary DNS is valid
   132:                         char DNS2:1;            // Secondary DNS is valid
   133:                         char HostName:1;        // Host name is valid (not implemented)
   134:                 } bits;
   135:                 BYTE val;
   136:         } validValues;
   137: } DHCP_CLIENT_VARS;
   138: 
   139: BOOL DHCPClientInitializedOnce = FALSE;
   140: 
   141: static BYTE _DHCPReceive(void);
   142: static void _DHCPSend(BYTE messageType, BOOL bRenewing);
   143: 
   144: #if defined (WF_CS_IO)
   145: extern void SignalDHCPSuccessful(void);
   146: #endif
   147: 
   148: 
   149: /*****************************************************************************
   150:   Function:
   151:         static void LoadState(BYTE vInterface)
   152: 
   153:   Summary:
   154:         Saves the DHCPClient state information structure to the appropriate 
   155:         location and loads DHCPClient with the state information for the specified 
   156:         interface.
   157: 
   158:   Description:
   159:         Saves the DHCPClient state information structure to the appropriate 
   160:         location and loads DHCPClient with the state information for the specified 
   161:         interface.
   162: 
   163:   Precondition:
   164:         None
   165: 
   166:   Parameters:
   167:         None
   168: 
   169:   Returns:
   170:         None
   171: 
   172:   Remarks:
   173:         This function does nothing when you only have one physical interface.
   174: ***************************************************************************/
   175: #if NETWORK_INTERFACES > 1
   176: 
   177: static DHCP_CLIENT_VARS DHCPClients[NETWORK_INTERFACES];
   178: static DHCP_CLIENT_VARS *SelectedDHCPClient;
   179: #define DHCPClient              (*SelectedDHCPClient)
   180: #define LoadState(v)    do(SelectedDHCPClient = &DHCPClients[v])while(0)
   181: 
   182: #else
   183: 
   184: static DHCP_CLIENT_VARS DHCPClient;
   185: #define LoadState(v)
   186: 
   187: #endif
   188: 
   189: 
   190: /*****************************************************************************
   191:   Function:
   192:         void DHCPInit(BYTE vInterface)
   193: 
   194:   Summary:
   195:         Resets the DHCP client module for the specified interface.
   196: 
   197:   Description:
   198:         Resets the DHCP client module, giving up any current lease, knowledge of 
   199:         DHCP servers, etc. for the specified interface.
   200: 
   201:   Precondition:
   202:         None
   203: 
   204:   Parameters:
   205:         vInterface - Interface number to initialize DHCP client state variables 
   206:                 for.   If you only have one interface, specify 0x00.
   207: 
   208:   Returns:
   209:         None
   210: 
   211:   Remarks:
   212:         This function may be called multiple times throughout the life of the 
   213:         application, if desired.  
   214: ***************************************************************************/
   215: void DHCPInit(BYTE vInterface)
   216: {
   217:         BYTE i;
   218:         
   219:         // Upon the first call after POR, we must reset all handles to invalid so 
   220:         // that we don't inadvertently close someone else's handle.
   221:         if(!DHCPClientInitializedOnce)
   222:         {
   223:                 DHCPClientInitializedOnce = TRUE;
   224:                 for(i = 0; i < NETWORK_INTERFACES; i++)
   225:                 {
   226:                         LoadState(i);
   227:                         DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET;
   228:                 }               
   229:         }
   230:         
   231:         
   232:         LoadState(vInterface);
   233:         
   234:         if(DHCPClient.hDHCPSocket != INVALID_UDP_SOCKET)
   235:         {
   236:                 UDPClose(DHCPClient.hDHCPSocket);
   237:                 DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET;
   238:         }
   239: 
   240:         // Reset state machine and flags to default values
   241:         DHCPClient.smState = SM_DHCP_GET_SOCKET;
   242:         DHCPClient.flags.val = 0;
   243:         DHCPClient.flags.bits.bUseUnicastMode = TRUE;   // This flag toggles before use, so this statement actually means to start out using broadcast mode.
   244:         DHCPClient.flags.bits.bEvent = TRUE;
   245: }
   246: 
   247: 
   248: /*****************************************************************************
   249:   Function:
   250:         void DHCPDisable(BYTE vInterface)
   251: 
   252:   Summary:
   253:         Disables the DHCP Client for the specified interface.
   254: 
   255:   Description:
   256:         Disables the DHCP client for the specified interface by sending the state 
   257:         machine to "SM_DHCP_DISABLED".  If the interface was previously configured 
   258:         by DHCP, the configuration will continue to be used but the module will no 
   259:         longer preform any renewals.
   260: 
   261:   Precondition:
   262:         None
   263: 
   264:   Parameters:
   265:         vInterface - Interface number to disable the DHCP client on.   If you only 
   266:                 have one interface, specify 0x00.
   267: 
   268:   Returns:
   269:         None
   270: 
   271:   Remarks:
   272:         Since the interface continues using its old configuration, it is possible 
   273:         that the lease may expire and the DHCP server provide the IP to another
   274:         client.  The application should replace the current IP address and other
   275:         configuration with static information following a call to this function.
   276: ***************************************************************************/
   277: void DHCPDisable(BYTE vInterface)
   278: {
   279:         LoadState(vInterface);
   280: 
   281:         if(DHCPClient.hDHCPSocket != INVALID_UDP_SOCKET)
   282:         {
   283:                 UDPClose(DHCPClient.hDHCPSocket);
   284:                 DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET;
   285:         }
   286: 
   287:         DHCPClient.smState = SM_DHCP_DISABLED;
   288: }
   289: 
   290: 
   291: /*****************************************************************************
   292:   Function:
   293:         void DHCPEnable(BYTE vInterface)
   294: 
   295:   Summary:
   296:         Enables the DHCP client for the specified interface.
   297: 
   298:   Description:
   299:         Enables the DHCP client for the specified interface, if it is disabled.  
   300:         If it is already enabled, nothing is done.
   301: 
   302:   Precondition:
   303:         None
   304: 
   305:   Parameters:
   306:         vInterface - Interface number to enable the DHCP client on.   If you only 
   307:                 have one interface, specify 0x00.
   308: 
   309:   Returns:
   310:         None
   311: ***************************************************************************/
   312: void DHCPEnable(BYTE vInterface)
   313: {
   314:         LoadState(vInterface);
   315: 
   316:         if(DHCPClient.smState == SM_DHCP_DISABLED)
   317:         {
   318:                 DHCPClient.smState = SM_DHCP_GET_SOCKET;
   319:                 DHCPClient.flags.bits.bIsBound = FALSE;
   320:         }
   321: }
   322: 
   323: /*****************************************************************************
   324:   Function:
   325:         BOOL DHCPIsEnabled(BYTE vInterface)
   326: 
   327:   Summary:
   328:         Determins if the DHCP client is enabled on the specified interface.
   329: 
   330:   Description:
   331:         Determins if the DHCP client is enabled on the specified interface.
   332: 
   333:   Precondition:
   334:         None
   335: 
   336:   Parameters:
   337:         vInterface - Interface number to query.   If you only have one interface, 
   338:                 specify 0x00.
   339: 
   340:   Returns:
   341:         None
   342: ***************************************************************************/
   343: BOOL DHCPIsEnabled(BYTE vInterface)
   344: {
   345:         LoadState(vInterface);
   346:         return DHCPClient.smState != SM_DHCP_DISABLED;
   347: }
   348: 
   349: 
   350: /*****************************************************************************
   351:   Function:
   352:         BOOL DHCPIsBound(BYTE vInterface)
   353: 
   354:   Summary:
   355:         Determins if the DHCP client has an IP address lease on the specified 
   356:         interface.
   357: 
   358:   Description:
   359:         Determins if the DHCP client has an IP address lease on the specified 
   360:         interface.
   361: 
   362:   Precondition:
   363:         None
   364: 
   365:   Parameters:
   366:         vInterface - Interface number to query.   If you only have one interface, 
   367:                 specify 0x00.
   368: 
   369:   Returns:
   370:         TRUE - DHCP client has obtained an IP address lease (and likely other 
   371:                 parameters) and these values are currently being used.
   372:         FALSE - No IP address is currently leased
   373: ***************************************************************************/
   374: BOOL DHCPIsBound(BYTE vInterface)
   375: {
   376:         LoadState(vInterface);
   377:         return DHCPClient.flags.bits.bIsBound;
   378: }
   379: 
   380: /*****************************************************************************
   381:   Function:
   382:         BOOL DHCPStateChanged(BYTE vInterface)
   383: 
   384:   Summary:
   385:         Determins if the DHCP client on the specified interface has changed states 
   386:         or refreshed its IP address lease.
   387: 
   388:   Description:
   389:         Determins if the DHCP client on the specified interface has changed states 
   390:         or refreshed its IP address lease.  This function can be used to determine
   391:         when to update an LCD or other display whenever the DHCP assigned IP 
   392:         address has potentially changed.
   393:         
   394:   Precondition:
   395:         None
   396: 
   397:   Parameters:
   398:         vInterface - Interface number to query.   If you only have one interface, 
   399:                 specify 0x00.
   400: 
   401:   Returns:
   402:         TRUE - The IP address lease have been reliquished (due to reinitilization), 
   403:                 obtained (first event), or renewed since the last call to 
   404:                 DHCPStateChanged().
   405:         FALSE - The DHCP client has not detected any changes since the last call to 
   406:                 DHCPStateChanged().
   407: ***************************************************************************/
   408: BOOL DHCPStateChanged(BYTE vInterface)
   409: {
   410:         LoadState(vInterface);
   411:         if(DHCPClient.flags.bits.bEvent)
   412:         {
   413:                 DHCPClient.flags.bits.bEvent = 0;
   414:                 return TRUE;
   415:         }
   416:         return FALSE;
   417: }
   418: 
   419: 
   420: /*****************************************************************************
   421:   Function:
   422:         BOOL DHCPIsServerDetected(BYTE vInterface)
   423: 
   424:   Summary:
   425:         Determins if the DHCP client on the specified interface has seen a DHCP 
   426:         server.
   427: 
   428:   Description:
   429:         Determins if the DHCP client on the specified interface has seen a DHCP 
   430:         server.
   431:         
   432:   Precondition:
   433:         None
   434: 
   435:   Parameters:
   436:         vInterface - Interface number to query.   If you only have one interface, 
   437:                 specify 0x00.
   438: 
   439:   Returns:
   440:         TRUE - At least one DHCP server is attached to the specified network 
   441:                 interface.
   442:         FALSE - No DHCP servers are currently detected on the specified network 
   443:                 interface.
   444: ***************************************************************************/
   445: BOOL DHCPIsServerDetected(BYTE vInterface)
   446: {
   447:         LoadState(vInterface);
   448:         return DHCPClient.flags.bits.bDHCPServerDetected;
   449: }
   450: 
   451: 
   452: /*****************************************************************************
   453:   Function:
   454:         void DHCPTask(void)
   455: 
   456:   Summary:
   457:         Performs periodic DHCP tasks for all interfaces.
   458: 
   459:   Description:
   460:         This function performs any periodic tasks requied by the DHCP module, 
   461:         such as sending and receiving messages involved with obtaining and
   462:         maintaining a lease.
   463: 
   464:   Precondition:
   465:         None
   466: 
   467:   Parameters:
   468:         None
   469: 
   470:   Returns:
   471:         None
   472: ***************************************************************************/
   473: void DHCPTask(void)
   474: {
   475:         BYTE i;
   476:         
   477:         for(i = 0; i < NETWORK_INTERFACES; i++)
   478:         {
   479:                 LoadState(i);
   480:                 switch(DHCPClient.smState)
   481:                 {
   482:                         case SM_DHCP_DISABLED:
   483:                                 // When the module is disabled, do absolutely nothing
   484:                                 break;
   485:                         
   486:                         case SM_DHCP_GET_SOCKET:
   487:                                 // Open a socket to send and receive broadcast messages on
   488:                                 //DHCPClient.hDHCPSocket = UDPOpen(DHCP_CLIENT_PORT, NULL, DHCP_SERVER_PORT);
   489:                                 
   490:                                 DHCPClient.hDHCPSocket = UDPOpenEx(0,UDP_OPEN_SERVER,DHCP_CLIENT_PORT, DHCP_SERVER_PORT);
   491:                                 if(DHCPClient.hDHCPSocket == INVALID_UDP_SOCKET)
   492:                                         break;
   493:         
   494:                                 DHCPClient.smState = SM_DHCP_SEND_DISCOVERY;
   495:                                 DHCPClient.dwSecs = 0;
   496:                                 // No break
   497:         
   498:                         case SM_DHCP_SEND_DISCOVERY:
   499:                                 // Assume default IP Lease time of 60 seconds.
   500:                                 // This should be minimum possible to make sure that if the
   501:                                 // server did not specify lease time, we try again after this 
   502:                                 // minimum time.
   503:                                 DHCPClient.dwLeaseTime = 60;
   504:                                 DHCPClient.validValues.val = 0x00;
   505:                                 DHCPClient.flags.bits.bIsBound = FALSE; 
   506:                                 DHCPClient.flags.bits.bOfferReceived = FALSE;
   507:         
   508:                                 // No point in wasting time transmitting a discovery if we are 
   509:                                 // unlinked.  No one will see it.  
   510:                                 if(!MACIsLinked())
   511:                                         break;
   512:                                         
   513:                 #if defined(WF_CS_IO)
   514:                     #if defined(STACK_USE_UART )
   515:                         putrsUART("DHCP Send Discovery...\r\n");
   516:                     #endif
   517:                 #endif
   518:         
   519:                                 // Ensure transmitter is ready to accept data
   520:                                 if(UDPIsPutReady(DHCPClient.hDHCPSocket) < 300u)
   521:                                         break;
   522: 
   523:                                 // Toggle the BOOTP Broadcast flag to ensure compatibility with 
   524:                                 // bad DHCP servers that don't know how to handle broadcast 
   525:                                 // responses.  This results in the next discovery attempt to be 
   526:                                 // made using the opposite mode.
   527:                                 DHCPClient.flags.bits.bUseUnicastMode ^= 1;
   528:         
   529:                                 // Ensure that we transmit to the broadcast IP and MAC addresses
   530:                                 // The UDP Socket remembers who it was last talking to
   531:                                 memset((void*)&UDPSocketInfo[DHCPClient.hDHCPSocket].remote.remoteNode, 0xFF, sizeof(UDPSocketInfo[0].remote.remoteNode));
   532:         
   533:                                 // Send the DHCP Discover broadcast
   534:                                 _DHCPSend(DHCP_DISCOVER_MESSAGE, FALSE);
   535:         
   536:                                 // Start a timer and begin looking for a response
   537:                                 DHCPClient.dwTimer = TickGet();
   538:                                 if (DHCPClient.dwSecs == 0) {
   539:                                         DHCPClient.dwSecs = TickGet();
   540:                                 }
   541:                                 DHCPClient.smState = SM_DHCP_GET_OFFER;
   542:                                 break;
   543:         
   544:                         case SM_DHCP_GET_OFFER:
   545:                                 // Check to see if a packet has arrived
   546:                                 if(UDPIsGetReady(DHCPClient.hDHCPSocket) < 250u)
   547:                                 {
   548:                                         // Go back and transmit a new discovery if we didn't get an offer after 2 seconds
   549:                                         if(TickGet() - DHCPClient.dwTimer >= DHCP_DISCOVERY_TIMEOUT) {
   550:                                                 DHCPClient.smState = SM_DHCP_SEND_DISCOVERY;
   551:                                                 DHCPClient.tempIPAddress.Val = 0x0;
   552:                                         }
   553:                                         break;
   554:                                 }
   555:         
   556:                                 // Let the DHCP server module know that there is a DHCP server 
   557:                                 // on this network
   558:                                 DHCPClient.flags.bits.bDHCPServerDetected = TRUE;
   559:         
   560:                                 // Check to see if we received an offer
   561:                                 if(_DHCPReceive() != DHCP_OFFER_MESSAGE)
   562:                                         break;
   563:         
   564:                                 DHCPClient.smState = SM_DHCP_SEND_REQUEST;
   565:                                 DHCPClient.dwSecs = 0; // Reset the secs timer
   566:                                 // No break
   567:         
   568:                         case SM_DHCP_SEND_REQUEST:
   569:                         case SM_DHCP_SEND_REQUEST2:
   570:                         case SM_DHCP_SEND_REQUEST3:
   571:                         case SM_DHCP_SEND_REQUEST4:
   572:                                 if(UDPIsPutReady(DHCPClient.hDHCPSocket) < 258u)
   573:                                         break;
   574: 
   575:                                 // Ensure that we transmit to the broadcast IP and MAC addresses
   576:                                 // The UDP Socket remembers who it was last talking to, so 
   577:                                 // we must set this back to the broadcast address since the 
   578:                                 // current socket values are the unicast addresses of the DHCP 
   579:                                 // server.
   580:                                 memset((void*)&UDPSocketInfo[DHCPClient.hDHCPSocket].remote.remoteNode, 0xFF, sizeof(UDPSocketInfo[0].remote.remoteNode));
   581:         
   582:                                 // Send the DHCP request message
   583:                                 _DHCPSend(DHCP_REQUEST_MESSAGE, FALSE);
   584:         
   585:                                 // Start a timer and begin looking for a response
   586:                                 DHCPClient.dwTimer = TickGet();
   587:                                 ++DHCPClient.smState;
   588:                                 break;
   589:         
   590:                         case SM_DHCP_GET_REQUEST_ACK:
   591:                         case SM_DHCP_GET_REQUEST_ACK2:
   592:                         case SM_DHCP_GET_REQUEST_ACK3:
   593:                         case SM_DHCP_GET_REQUEST_ACK4:
   594:                                 // Check to see if a packet has arrived
   595:                                 if(UDPIsGetReady(DHCPClient.hDHCPSocket) < 250u)
   596:                                 {
   597:                                         // Go back and transmit a new request if we didn't get an ACK after 15 seconds
   598:                                         if(TickGet() - DHCPClient.dwTimer >= DHCP_REQUEST_TIMEOUT) {
   599:                                                 if(++DHCPClient.smState > SM_DHCP_GET_REQUEST_ACK4) {
   600:                                                         // Fourth retry failed, go back to discovery
   601:                                                         DHCPClient.smState = SM_DHCP_SEND_DISCOVERY;
   602:                                                 }
   603:                                         }
   604:                                         break;
   605:                                 }
   606:         
   607:                                 // Check to see if we received an offer
   608:                                 switch(_DHCPReceive())
   609:                                 {
   610:                                         case DHCP_ACK_MESSAGE:
   611:                                                 UDPClose(DHCPClient.hDHCPSocket);
   612:                                                 DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET;
   613:                                                 DHCPClient.dwTimer = TickGet();
   614:                                                 DHCPClient.smState = SM_DHCP_BOUND;
   615:                                                 DHCPClient.flags.bits.bEvent = 1;
   616:                                                 DHCPClient.flags.bits.bIsBound = TRUE;  
   617: 
   618:                                                 if(DHCPClient.validValues.bits.IPAddress)
   619:                                                 {
   620:                                                         AppConfig.MyIPAddr = DHCPClient.tempIPAddress;
   621:                                                         #if defined(WF_CS_IO) 
   622:                                                             #if defined(STACK_USE_UART )
   623:                                                                 putrsUART("DHCP client successful\r\n");
   624:                                                             #endif
   625:                                                         SignalDHCPSuccessful();
   626:                                                         #endif
   627:                                                 }       
   628:                                                 if(DHCPClient.validValues.bits.Mask)
   629:                                                         AppConfig.MyMask = DHCPClient.tempMask;
   630:                                                 if(DHCPClient.validValues.bits.Gateway)
   631:                                                         AppConfig.MyGateway = DHCPClient.tempGateway;
   632:                                                 #if defined(STACK_USE_DNS)
   633:                                                         if(DHCPClient.validValues.bits.DNS)
   634:                                                                 AppConfig.PrimaryDNSServer.Val = DHCPClient.tempDNS.Val;
   635:                                                         AppConfig.SecondaryDNSServer.Val = 0x00000000ul;
   636:                                                         if(DHCPClient.validValues.bits.DNS2)
   637:                                                                 AppConfig.SecondaryDNSServer.Val = DHCPClient.tempDNS2.Val;
   638:                                                 #endif
   639:                                                 //if(DHCPClient.validValues.bits.HostName)
   640:                                                 //      memcpy(AppConfig.NetBIOSName, (void*)DHCPClient.tempHostName, sizeof(AppConfig.NetBIOSName));
   641:         
   642:                                                 break;
   643:         
   644:                                         case DHCP_NAK_MESSAGE:
   645:                                                 DHCPClient.smState = SM_DHCP_SEND_DISCOVERY;
   646:                                                 break;
   647:                                 }
   648:                                 break;
   649:         
   650:                         case SM_DHCP_BOUND:
   651:                                 if(TickGet() - DHCPClient.dwTimer < TICK_SECOND)
   652:                                         break;
   653:         
   654:                                 // Check to see if our lease is still valid, if so, decrement lease 
   655:                                 // time
   656:                                 if(DHCPClient.dwLeaseTime >= 2ul)
   657:                                 {
   658:                                         DHCPClient.dwTimer += TICK_SECOND;
   659:                                         DHCPClient.dwLeaseTime--;
   660:                                         break;
   661:                                 }
   662:         
   663:                                 // Open a socket to send and receive DHCP messages on
   664:                                 //DHCPClient.hDHCPSocket = UDPOpen(DHCP_CLIENT_PORT, NULL, DHCP_SERVER_PORT);
   665:                                 
   666:                                 DHCPClient.hDHCPSocket = UDPOpenEx(0,UDP_OPEN_SERVER,DHCP_CLIENT_PORT, DHCP_SERVER_PORT);
   667:                                 if(DHCPClient.hDHCPSocket == INVALID_UDP_SOCKET)
   668:                                         break;
   669:         
   670:                                 DHCPClient.smState = SM_DHCP_SEND_RENEW;
   671:                                 // No break
   672:         
   673:                         case SM_DHCP_SEND_RENEW:
   674:                         case SM_DHCP_SEND_RENEW2:
   675:                         case SM_DHCP_SEND_RENEW3:
   676:                                 if(UDPIsPutReady(DHCPClient.hDHCPSocket) < 258u)
   677:                                         break;
   678:         
   679:                                 // Send the DHCP request message
   680:                                 _DHCPSend(DHCP_REQUEST_MESSAGE, TRUE);
   681:                                 DHCPClient.flags.bits.bOfferReceived = FALSE;
   682:         
   683:                                 // Start a timer and begin looking for a response
   684:                                 DHCPClient.dwTimer = TickGet();
   685:                                 DHCPClient.smState++;
   686:                                 break;
   687:         
   688:                         case SM_DHCP_GET_RENEW_ACK:
   689:                         case SM_DHCP_GET_RENEW_ACK2:
   690:                         case SM_DHCP_GET_RENEW_ACK3:
   691:                                 // Check to see if a packet has arrived
   692:                                 if(UDPIsGetReady(DHCPClient.hDHCPSocket) < 250u)
   693:                                 {
   694:                                         // Go back and transmit a new discovery if we didn't get an ACK after 2 seconds
   695:                                         if(TickGet() - DHCPClient.dwTimer >=  DHCP_REQUEST_TIMEOUT)
   696:                                         {
   697:                                                 if(++DHCPClient.smState > SM_DHCP_GET_RENEW_ACK3)
   698:                                                         DHCPClient.smState = SM_DHCP_SEND_DISCOVERY;
   699:                                         }
   700:                                         break;
   701:                                 }
   702:         
   703:                                 // Check to see if we received an offer
   704:                                 switch(_DHCPReceive())
   705:                                 {
   706:                                         case DHCP_ACK_MESSAGE:
   707:                                                 UDPClose(DHCPClient.hDHCPSocket);
   708:                                                 DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET;
   709:                                                 DHCPClient.dwTimer = TickGet();
   710:                                                 DHCPClient.smState = SM_DHCP_BOUND;
   711:                                                 DHCPClient.flags.bits.bEvent = 1;
   712:                                                 break;
   713:                 
   714:                                         case DHCP_NAK_MESSAGE:
   715:                                                 DHCPClient.smState = SM_DHCP_SEND_DISCOVERY;
   716:                                                 break;
   717:                                 }
   718:                                 break;
   719:                 }
   720:         }
   721: }
   722: 
   723: 
   724: 
   725: /*****************************************************************************
   726: Function:
   727:   void _DHCPReceive(void)
   728: 
   729: Description:
   730:   Receives and parses a DHCP message.
   731: 
   732: Precondition:
   733:   A DHCP message is waiting in the UDP buffer.
   734: 
   735: Parameters:
   736:   None
   737: 
   738: Returns:
   739:   One of the DCHP_TYPE* contants.
   740: ***************************************************************************/
   741: static BYTE _DHCPReceive(void)
   742: {
   743:         /*********************************************************************
   744:         DHCP PACKET FORMAT AS PER RFC 1541
   745: 
   746:         0                   1                   2                   3
   747:         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   748:         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   749:         |     op (1)    |   htype (1)   |   hlen (1)    |   hops (1)    |
   750:         +---------------+---------------+---------------+---------------+
   751:         |                            xid (4)                            |
   752:         +-------------------------------+-------------------------------+
   753:         |           secs (2)            |           flags (2)           |
   754:         +-------------------------------+-------------------------------+
   755:         |                          ciaddr  (4)                          |
   756:         +---------------------------------------------------------------+
   757:         |                          yiaddr  (4)                          |
   758:         +---------------------------------------------------------------+
   759:         |                          siaddr  (4)                          |
   760:         +---------------------------------------------------------------+
   761:         |                          giaddr  (4)                          |
   762:         +---------------------------------------------------------------+
   763:         |                                                               |
   764:         |                          chaddr  (16)                         |
   765:         |                                                               |
   766:         |                                                               |
   767:         +---------------------------------------------------------------+
   768:         |                                                               |
   769:         |                          sname   (64)                         |
   770:         +---------------------------------------------------------------+
   771:         |                                                               |
   772:         |                          file    (128)                        |
   773:         +---------------------------------------------------------------+
   774:         |                                                               |
   775:         |                          options (312)                        |
   776:         +---------------------------------------------------------------+
   777: 
   778:         ********************************************************************/
   779:         BYTE v;
   780:         BYTE i, j;
   781:         BYTE type;
   782:         BOOL lbDone;
   783:         DWORD tempServerID;
   784: 
   785: 
   786:         // Assume unknown message until proven otherwise.
   787:         type = DHCP_UNKNOWN_MESSAGE;
   788: 
   789:         UDPGet(&v);                             // op
   790: 
   791:         // Make sure this is BOOT_REPLY.
   792:         if ( v == BOOT_REPLY )
   793:         {
   794:                 // Jump to chaddr field (Client Hardware Address -- our MAC address for 
   795:                 // Ethernet and WiFi networks) and verify that this message is directed 
   796:                 // to us before doing any other processing.
   797:                 UDPSetRxBuffer(28);             // chaddr field is at offset 28 in the UDP packet payload -- see DHCP packet format above
   798:                 for ( i = 0; i < 6u; i++ )
   799:                 {
   800:                         UDPGet(&v);
   801:                         if ( v != AppConfig.MyMACAddr.v[i])
   802:                                 goto UDPInvalid;
   803:                 }
   804: 
   805:                 // Check to see if this is the first offer.  If it is, record its 
   806:                 // yiaddr value ("Your (client) IP address") so that we can REQUEST to 
   807:                 // use it later.
   808:                 if(!DHCPClient.flags.bits.bOfferReceived)
   809:                 {
   810:                         UDPSetRxBuffer(16);
   811:                         UDPGetArray((BYTE*)&DHCPClient.tempIPAddress, sizeof(DHCPClient.tempIPAddress));
   812:                         DHCPClient.validValues.bits.IPAddress = 1;
   813:                 }
   814: 
   815:                 // Jump to DHCP options (ignore htype, hlen, hops, xid, secs, flags, 
   816:                 // ciaddr, siaddr, giaddr, padding part of chaddr, sname, file, magic 
   817:                 // cookie fields)
   818:                 UDPSetRxBuffer(240);
   819: 
   820:                 lbDone = FALSE;
   821:                 do
   822:                 {
   823:                         // Get the Option number
   824:                         // Break out eventually in case if this is a malformed 
   825:                         // DHCP message, ie: missing DHCP_END_OPTION marker
   826:                         if(!UDPGet(&v))
   827:                         {
   828:                                 lbDone = TRUE;
   829:                                 break;
   830:                         }
   831: 
   832:                         switch(v)
   833:                         {
   834:                                 case DHCP_MESSAGE_TYPE:
   835:                                         UDPGet(&v);                         // Skip len
   836:                                         // Len must be 1.
   837:                                         if ( v == 1u )
   838:                                         {
   839:                                                 UDPGet(&type);                  // Get type
   840: 
   841:                                                 // Throw away the packet if we know we don't need it (ie: another offer when we already have one)
   842:                                                 if(DHCPClient.flags.bits.bOfferReceived && (type == DHCP_OFFER_MESSAGE))
   843:                                                 {
   844:                                                         goto UDPInvalid;
   845:                                                 }
   846:                                         }
   847:                                         else
   848:                                                 goto UDPInvalid;
   849:                                         break;
   850: 
   851:                                 case DHCP_SUBNET_MASK:
   852:                                         UDPGet(&v);                     // Skip len
   853:                                         // Len must be 4.
   854:                                         if ( v == 4u )
   855:                                         {
   856:                                                 // Check to see if this is the first offer
   857:                                                 if(DHCPClient.flags.bits.bOfferReceived)
   858:                                                 {
   859:                                                         // Discard offered IP mask, we already have an offer
   860:                                                         for ( i = 0; i < 4u; i++ )
   861:                                                                 UDPGet(&v);
   862:                                                 }
   863:                                                 else
   864:                                                 {
   865:                                                         UDPGetArray((BYTE*)&DHCPClient.tempMask, sizeof(DHCPClient.tempMask));
   866:                                                         DHCPClient.validValues.bits.Mask = 1;
   867:                                                 }
   868:                                         }
   869:                                         else
   870:                                                 goto UDPInvalid;
   871:                                         break;
   872: 
   873:                                 case DHCP_ROUTER:
   874:                                         UDPGet(&j);
   875:                                         // Len must be >= 4.
   876:                                         if ( j >= 4u )
   877:                                         {
   878:                                                 // Check to see if this is the first offer
   879:                                                 if(DHCPClient.flags.bits.bOfferReceived)
   880:                                                 {
   881:                                                         // Discard offered Gateway address, we already have an offer
   882:                                                         for ( i = 0; i < 4u; i++ )
   883:                                                                 UDPGet(&v);
   884:                                                 }
   885:                                                 else
   886:                                                 {
   887:                                                         UDPGetArray((BYTE*)&DHCPClient.tempGateway, sizeof(DHCPClient.tempGateway));
   888:                                                         DHCPClient.validValues.bits.Gateway = 1;
   889:                                                 }
   890:                                         }
   891:                                         else
   892:                                                 goto UDPInvalid;
   893: 
   894:                                         // Discard any other router addresses.
   895:                                         j -= 4;
   896:                                         while(j--)
   897:                                                 UDPGet(&v);
   898:                                         break;
   899: 
   900:                                 #if defined(STACK_USE_DNS)
   901:                                 case DHCP_DNS:
   902:                                         UDPGet(&j);
   903:                                         // Len must be >= 4.
   904:                                         if(j < 4u)
   905:                                                 goto UDPInvalid;
   906: 
   907:                                         // Check to see if this is the first offer
   908:                                         if(!DHCPClient.flags.bits.bOfferReceived)
   909:                                         {
   910:                                                 UDPGetArray((BYTE*)&DHCPClient.tempDNS, sizeof(DHCPClient.tempDNS));
   911:                                                 DHCPClient.validValues.bits.DNS = 1;
   912:                                                 j -= 4;
   913:                                         }
   914: 
   915:                                         // Len must be >= 4 for a secondary DNS server address
   916:                                         if(j >= 4u)
   917:                                         {
   918:                                                 // Check to see if this is the first offer
   919:                                                 if(!DHCPClient.flags.bits.bOfferReceived)
   920:                                                 {
   921:                                                         UDPGetArray((BYTE*)&DHCPClient.tempDNS2, sizeof(DHCPClient.tempDNS2));
   922:                                                         DHCPClient.validValues.bits.DNS2 = 1;
   923:                                                         j -= 4;
   924:                                                 }
   925:                                         }
   926: 
   927:                                         // Discard any other DNS server addresses
   928:                                         while(j--)
   929:                                                 UDPGet(&v);
   930:                                         break;
   931:                                 #endif
   932: 
   933:                                         //            case DHCP_HOST_NAME:
   934:                                         //                UDPGet(&j);
   935:                                         //                // Len must be >= 4.
   936:                                         //                if(j < 1u)
   937:                                         //                                      goto UDPInvalid;
   938:                                         //
   939:                                         //                              // Check to see if this is the first offer
   940:                                         //                              if(DHCPFlags.bits.bOfferReceived)
   941:                                         //                              {
   942:                                         //                              // Discard offered host name, we already have an offer
   943:                                         //                      while(j--)
   944:                                         //                          UDPGet(&v);
   945:                                         //                              }
   946:                                         //                              else
   947:                                         //                              {
   948:                                         //                                      for(i = 0; j, i < sizeof(tempHostName); i++, j--)
   949:                                         //                                      {
   950:                                         //                                              UDPGet(&tempHostName[i]);
   951:                                         //                                      }
   952:                                         //                                      while(j--)
   953:                                         //                                      {
   954:                                         //                                              UDPGet(&v);
   955:                                         //                                      }
   956:                                         //                                      ValidValues.bits.HostName = 1;
   957:                                         //                              }
   958:                                         //
   959:                                         //                break;
   960: 
   961:                                 case DHCP_SERVER_IDENTIFIER:
   962:                                         UDPGet(&v);                         // Get len
   963:                                         // Len must be 4.
   964:                                         if ( v == 4u )
   965:                                         {
   966:                                                 UDPGet(&(((BYTE*)&tempServerID)[3]));   // Get the id
   967:                                                 UDPGet(&(((BYTE*)&tempServerID)[2]));
   968:                                                 UDPGet(&(((BYTE*)&tempServerID)[1]));
   969:                                                 UDPGet(&(((BYTE*)&tempServerID)[0]));
   970:                                         }
   971:                                         else
   972:                                                 goto UDPInvalid;
   973:                                         break;
   974: 
   975:                                 case DHCP_END_OPTION:
   976:                                         lbDone = TRUE;
   977:                                         break;
   978: 
   979:                                 case DHCP_IP_LEASE_TIME:
   980:                                         UDPGet(&v);                         // Get len
   981:                                         // Len must be 4.
   982:                                         if ( v == 4u )
   983:                                         {
   984:                                                 // Check to see if this is the first offer
   985:                                                 if(DHCPClient.flags.bits.bOfferReceived)
   986:                                                 {
   987:                                                         // Discard offered lease time, we already have an offer
   988:                                                         for ( i = 0; i < 4u; i++ )
   989:                                                                 UDPGet(&v);
   990:                                                 }
   991:                                                 else
   992:                                                 {
   993:                                                         UDPGet(&(((BYTE*)(&DHCPClient.dwLeaseTime))[3]));
   994:                                                         UDPGet(&(((BYTE*)(&DHCPClient.dwLeaseTime))[2]));
   995:                                                         UDPGet(&(((BYTE*)(&DHCPClient.dwLeaseTime))[1]));
   996:                                                         UDPGet(&(((BYTE*)(&DHCPClient.dwLeaseTime))[0]));
   997: 
   998:                                                         // In case if our clock is not as accurate as the remote 
   999:                                                         // DHCP server's clock, let's treat the lease time as only 
  1000:                                                         // 96.875% of the value given
  1001:                                                         DHCPClient.dwLeaseTime -= DHCPClient.dwLeaseTime>>5;
  1002:                                                 }
  1003:                                         }
  1004:                                         else
  1005:                                                 goto UDPInvalid;
  1006:                                         break;
  1007: 
  1008:                                 default:
  1009:                                         // Ignore all unsupport tags.
  1010:                                         UDPGet(&j);                     // Get option len
  1011:                                         while( j-- )                    // Ignore option values
  1012:                                                 UDPGet(&v);
  1013:                         }
  1014:                 } while( !lbDone );
  1015:         }
  1016: 
  1017:         // If this is an OFFER message, remember current server id.
  1018:         if ( type == DHCP_OFFER_MESSAGE )
  1019:         {
  1020:                 DHCPClient.dwServerID = tempServerID;
  1021:                 DHCPClient.flags.bits.bOfferReceived = TRUE;
  1022:         }
  1023:         else
  1024:         {
  1025:                 // For other types of messages, make sure that received
  1026:                 // server id matches with our previous one.
  1027:                 if ( DHCPClient.dwServerID != tempServerID )
  1028:                         type = DHCP_UNKNOWN_MESSAGE;
  1029:         }
  1030: 
  1031:         UDPDiscard();                             // We are done with this packet
  1032:         return type;
  1033: 
  1034: UDPInvalid:
  1035:         UDPDiscard();
  1036:         return DHCP_UNKNOWN_MESSAGE;
  1037: }
  1038: 
  1039: 
  1040: 
  1041: 
  1042: /*****************************************************************************
  1043:   Function:
  1044:         static void _DHCPSend(BYTE messageType, BOOL bRenewing)
  1045: 
  1046:   Description:
  1047:         Sends a DHCP message.
  1048: 
  1049:   Precondition:
  1050:         UDP is ready to write a DHCP packet.
  1051: 
  1052:   Parameters:
  1053:         messageType - One of the DHCP_TYPE constants
  1054:         bRenewing - Whether or not this is a renewal request
  1055: 
  1056:   Returns:
  1057:         None
  1058: ***************************************************************************/
  1059: static void _DHCPSend(BYTE messageType, BOOL bRenewing)
  1060: {
  1061:         BYTE i;
  1062:         IP_ADDR MyIP;
  1063: 
  1064:         DWORD s = 0;
  1065:         if (DHCPClient.dwSecs) {
  1066:                 s = (TickGet() - DHCPClient.dwSecs) / TICK_SECOND;
  1067:         }
  1068: 
  1069:         UDPPut(BOOT_REQUEST);                       // op
  1070:         UDPPut(BOOT_HW_TYPE);                       // htype
  1071:         UDPPut(BOOT_LEN_OF_HW_TYPE);                // hlen
  1072:         UDPPut(0);                                  // hops
  1073:         UDPPut(0x12);                               // xid[0]
  1074:         UDPPut(0x23);                               // xid[1]
  1075:         UDPPut(0x34);                               // xid[2]
  1076:         UDPPut(0x56);                               // xid[3]
  1077:         UDPPut(((BYTE*)(&s))[1]);                   // secs[0]
  1078:         UDPPut(((BYTE*)(&s))[0]);                   // secs[1]
  1079:         UDPPut(DHCPClient.flags.bits.bUseUnicastMode ? 0x00: 0x80);// flags[0] with Broadcast flag clear/set to correspond to bUseUnicastMode
  1080:         UDPPut(0);                                  // flags[1]
  1081: 
  1082:         // If this is DHCP REQUEST message, use previously allocated IP address.
  1083:         if((messageType == DHCP_REQUEST_MESSAGE) && bRenewing)
  1084:         {
  1085:                 UDPPutArray((BYTE*)&DHCPClient.tempIPAddress, sizeof(DHCPClient.tempIPAddress));
  1086:         }
  1087:         else
  1088:         {
  1089:                 UDPPut(0x00);
  1090:                 UDPPut(0x00);
  1091:                 UDPPut(0x00);
  1092:                 UDPPut(0x00);
  1093:         }
  1094: 
  1095:         // Set yiaddr, siaddr, giaddr as zeros,
  1096:         for ( i = 0; i < 12u; i++ )
  1097:                 UDPPut(0x00);
  1098: 
  1099:         // Load chaddr - Client hardware address.
  1100:         UDPPutArray((BYTE*)&AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr));
  1101: 
  1102:         // Set chaddr[6..15], sname and file as zeros.
  1103:         for ( i = 0; i < 202u; i++ )
  1104:                 UDPPut(0);
  1105: 
  1106:         // Load magic cookie as per RFC 1533.
  1107:         UDPPut(99);
  1108:         UDPPut(130);
  1109:         UDPPut(83);
  1110:         UDPPut(99);
  1111: 
  1112:         // Load message type.
  1113:         UDPPut(DHCP_MESSAGE_TYPE);
  1114:         UDPPut(DHCP_MESSAGE_TYPE_LEN);
  1115:         UDPPut(messageType);
  1116: 
  1117:         if(messageType == DHCP_DISCOVER_MESSAGE)
  1118:         {
  1119:                 // Reset offered flag so we know to act upon the next valid offer
  1120:                 DHCPClient.flags.bits.bOfferReceived = FALSE;
  1121:         }
  1122: 
  1123: 
  1124:         if((messageType == DHCP_REQUEST_MESSAGE) && !bRenewing)
  1125:         {
  1126:                 // DHCP REQUEST message must include server identifier the first time
  1127:                 // to identify the server we are talking to.
  1128:                 // _DHCPReceive() would populate "serverID" when it
  1129:                 // receives DHCP OFFER message. We will simply use that
  1130:                 // when we are replying to server.
  1131:                 // If this is a renwal request, we must not include server id.
  1132:                 UDPPut(DHCP_SERVER_IDENTIFIER);
  1133:                 UDPPut(DHCP_SERVER_IDENTIFIER_LEN);
  1134:                 UDPPut(((BYTE*)(&DHCPClient.dwServerID))[3]);
  1135:                 UDPPut(((BYTE*)(&DHCPClient.dwServerID))[2]);
  1136:                 UDPPut(((BYTE*)(&DHCPClient.dwServerID))[1]);
  1137:                 UDPPut(((BYTE*)(&DHCPClient.dwServerID))[0]);
  1138:         }
  1139: 
  1140:         // Load our interested parameters
  1141:         // This is hardcoded list.  If any new parameters are desired,
  1142:         // new lines must be added here.
  1143:         UDPPut(DHCP_PARAM_REQUEST_LIST);
  1144:         UDPPut(DHCP_PARAM_REQUEST_LIST_LEN);
  1145:         UDPPut(DHCP_SUBNET_MASK);
  1146:         UDPPut(DHCP_ROUTER);
  1147:         UDPPut(DHCP_DNS);
  1148:         UDPPut(DHCP_HOST_NAME);
  1149: 
  1150:         // Add requested IP address to DHCP Request Message
  1151:         if( ((messageType == DHCP_REQUEST_MESSAGE) && !bRenewing) || 
  1152:                 ((messageType == DHCP_DISCOVER_MESSAGE) && DHCPClient.tempIPAddress.Val))
  1153:         {
  1154:                 UDPPut(DHCP_PARAM_REQUEST_IP_ADDRESS);
  1155:                 UDPPut(DHCP_PARAM_REQUEST_IP_ADDRESS_LEN);
  1156:                 UDPPutArray((BYTE*)&DHCPClient.tempIPAddress, DHCP_PARAM_REQUEST_IP_ADDRESS_LEN);
  1157:         }
  1158: 
  1159:         // Add any new paramter request here.
  1160: 
  1161:         // End of Options.
  1162:         UDPPut(DHCP_END_OPTION);
  1163: 
  1164:         // Add zero padding to ensure compatibility with old BOOTP relays that discard small packets (<300 UDP octets)
  1165:         while(UDPTxCount < 300u)
  1166:                 UDPPut(0); 
  1167: 
  1168:         // Make sure we advertise a 0.0.0.0 IP address so all DHCP servers will respond.  If we have a static IP outside the DHCP server's scope, it may simply ignore discover messages.
  1169:         MyIP.Val = AppConfig.MyIPAddr.Val;
  1170:         if(!bRenewing)
  1171:                 AppConfig.MyIPAddr.Val = 0x00000000;
  1172:         UDPFlush();
  1173:         AppConfig.MyIPAddr.Val = MyIP.Val;
  1174: 
  1175: }
  1176: 
  1177: 
  1178: #endif  //#if defined(STACK_USE_DHCP_CLIENT)
