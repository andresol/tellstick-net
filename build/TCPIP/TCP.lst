     1: /*********************************************************************
     2:  *
     3:  *      Transmission Control Protocol (TCP) Communications Layer
     4:  *  Module for Microchip TCP/IP Stack
     5:  *       -Provides reliable, handshaked transport of application stream 
     6:  *    oriented data with flow control
     7:  *       -Reference: RFC 793
     8:  *
     9:  *********************************************************************
    10:  * FileName:        TCP.c
    11:  * Dependencies:    IP, Tick, Ethernet/WiFi (ENC28J60.c, ETH97J60.c, 
    12:  *                                      ENCX24J600.c, or WFMac.c), ARP (optional), 
    13:  *                                      DNS (optional)
    14:  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
    15:  * Compiler:        Microchip C32 v1.05 or higher
    16:  *                                      Microchip C30 v3.12 or higher
    17:  *                                      Microchip C18 v3.30 or higher
    18:  *                                      HI-TECH PICC-18 PRO 9.63PL2 or higher
    19:  * Company:         Microchip Technology, Inc.
    20:  *
    21:  * Software License Agreement
    22:  *
    23:  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
    24:  * reserved.
    25:  *
    26:  * Microchip licenses to you the right to use, modify, copy, and
    27:  * distribute:
    28:  * (i)  the Software when embedded on a Microchip microcontroller or
    29:  *      digital signal controller product ("Device") which is
    30:  *      integrated into Licensee's product; or
    31:  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
    32:  *              ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
    33:  *              used in conjunction with a Microchip ethernet controller for
    34:  *              the sole purpose of interfacing with the ethernet controller.
    35:  *
    36:  * You should refer to the license agreement accompanying this
    37:  * Software for additional information regarding your rights and
    38:  * obligations.
    39:  *
    40:  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
    41:  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
    42:  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
    43:  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
    44:  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
    45:  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
    46:  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
    47:  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
    48:  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
    49:  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
    50:  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
    51:  *
    52:  *
    53:  * Author               Date            Comment
    54:  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    55:  * Nilesh Rajbharti     5/8/01          Original        (Rev 1.0)
    56:  * Howard Schlunder             12/11/06        Changed almost everything to 
    57:  *                                                                      better meet RFC 793.
    58:  ********************************************************************/
    59: #define __TCP_C
    60: 
    61: #include "TCPIP Stack/TCPIP.h"
    62: 
    63: #if defined(STACK_USE_TCP)
    64: 
    65: /****************************************************************************
    66:   Section:
    67:         Configuration Parameters
    68:   ***************************************************************************/
    69: 
    70: // Starting port for client sockets
    71: #define LOCAL_PORT_START_NUMBER (1024u)
    72: // End port for client sockets
    73: #define LOCAL_PORT_END_NUMBER   (5000u)
    74: 
    75: // For debugging only.  Normal applications should never enable these
    76: //#define DEBUG_GENERATE_TX_LOSS                62257
    77: //#define DEBUG_GENERATE_RX_LOSS                64225
    78: 
    79: // A lot of pointer dereference code can be removed if you 
    80: // locally copy TCBStubs to an absolute memory location.
    81: // If you define TCP_OPTIMIZE_FOR_SIZE, local caching will 
    82: // occur and will substantially decrease the entire TCP ROM 
    83: // footprint (up to 35%).  If you leave TCP_OPTIMIZE_FOR_SIZE 
    84: // undefined, the local caching will be disabled.  On PIC18 
    85: // products, this will improve TCP performance/throughput by 
    86: // approximately 15%.
    87: #define TCP_OPTIMIZE_FOR_SIZE
    88: 
    89: // For smallest size and best throughput, TCP_OPTIMIZE_FOR_SIZE 
    90: // should always be enabled on PIC24/dsPIC products.  On PIC32 
    91: // products there is very little difference and depnds on compiler 
    92: // optimization level
    93: #if defined(__C30__) && !defined(TCP_OPTIMIZE_FOR_SIZE)
    94:         #define TCP_OPTIMIZE_FOR_SIZE
    95: #elif defined(__C32__) && defined(TCP_OPTIMIZE_FOR_SIZE)
    96:         #undef TCP_OPTIMIZE_FOR_SIZE
    97: #endif
    98: 
    99: // TCP Maximum Segment Size for TX.  The TX maximum segment size is actually 
   100: // govered by the remote node's MSS option advirtised during connection 
   101: // establishment.  However, if the remote node specifies an unhandlably large 
   102: // MSS (ex: > Ethernet MTU), this define sets a hard limit so that we don't 
   103: // cause any TX buffer overflows.  If the remote node does not advirtise a MSS 
   104: // option, all TX segments are fixed at 536 bytes maximum.
   105: #define TCP_MAX_SEG_SIZE_TX                     (1460u)
   106: 
   107: // TCP Maximum Segment Size for RX.  This value is advirtised during connection 
   108: // establishment and the remote node should obey it.  This should be set to 536 
   109: // to avoid IP layer fragmentation from causing packet loss.  However, raising 
   110: // its value can enhance performance at the (small) risk of introducing 
   111: // incompatibility with certain special remote nodes (ex: ones connected via a 
   112: // slow dial up modem).
   113: #define TCP_MAX_SEG_SIZE_RX                     (536u)
   114: 
   115: // TCP Timeout and retransmit numbers
   116: #define TCP_START_TIMEOUT_VAL           ((DWORD)TICK_SECOND*1)  // Timeout to retransmit unacked data
   117: #define TCP_DELAYED_ACK_TIMEOUT         ((DWORD)TICK_SECOND/10) // Timeout for delayed-acknowledgement algorithm
   118: #define TCP_FIN_WAIT_2_TIMEOUT          ((DWORD)TICK_SECOND*5)  // Timeout for FIN WAIT 2 state
   119: #define TCP_KEEP_ALIVE_TIMEOUT          ((DWORD)TICK_SECOND*10) // Timeout for keep-alive messages when no traffic is sent
   120: #define TCP_CLOSE_WAIT_TIMEOUT          ((DWORD)TICK_SECOND/5)  // Timeout for the CLOSE_WAIT state
   121: #define TCP_MAX_RETRIES                     (5u)                                        // Maximum number of retransmission attempts
   122: #define TCP_MAX_UNACKED_KEEP_ALIVES     (6u)                                    // Maximum number of keep-alive messages that can be sent without receiving a response before automatically closing the connection
   123: #define TCP_MAX_SYN_RETRIES                     (2u)    // Smaller than all other retries to reduce SYN flood DoS duration
   124: 
   125: #define TCP_AUTO_TRANSMIT_TIMEOUT_VAL   (TICK_SECOND/25ull)     // Timeout before automatically transmitting unflushed data
   126: #define TCP_WINDOW_UPDATE_TIMEOUT_VAL   (TICK_SECOND/5ull)      // Timeout before automatically transmitting a window update due to a TCPGet() or TCPGetArray() function call
   127: 
   128: #define TCP_SYN_QUEUE_MAX_ENTRIES       (3u)                                    // Number of TCP RX SYN packets to save if they cannot be serviced immediately
   129: #define TCP_SYN_QUEUE_TIMEOUT           ((DWORD)TICK_SECOND*3)  // Timeout for when SYN queue entries are deleted if unserviceable
   130: 
   131: /****************************************************************************
   132:   Section:
   133:         TCP Header Data Types
   134:   ***************************************************************************/
   135: 
   136: #define FIN     (0x01)          // FIN Flag as defined in RFC
   137: #define SYN     (0x02)          // SYN Flag as defined in RFC
   138: #define RST     (0x04)          // Reset Flag as defined in RFC
   139: #define PSH     (0x08)          // Push Flag as defined in RFC
   140: #define ACK     (0x10)          // Acknowledge Flag as defined in RFC
   141: #define URG     (0x20)          // Urgent Flag as defined in RFC
   142: 
   143: // TCP Header Data Structure
   144: typedef struct
   145: {
   146:         WORD    SourcePort;             // Local port number
   147:         WORD    DestPort;               // Remote port number
   148:         DWORD   SeqNumber;              // Local sequence number
   149:         DWORD   AckNumber;              // Acknowledging remote sequence number
   150: 
   151:         struct
   152:         {
   153:                 unsigned char Reserved3      : 4;
   154:                 unsigned char Val            : 4;
   155:         } DataOffset;                   // Data offset flags nibble
   156: 
   157:         union
   158:         {
   159:                 struct
   160:                 {
   161:                         unsigned char flagFIN    : 1;
   162:                         unsigned char flagSYN    : 1;
   163:                         unsigned char flagRST    : 1;
   164:                         unsigned char flagPSH    : 1;
   165:                         unsigned char flagACK    : 1;
   166:                         unsigned char flagURG    : 1;
   167:                         unsigned char Reserved2  : 2;
   168:                 } bits;
   169:                 BYTE byte;
   170:         } Flags;                                // TCP Flags as defined in RFC
   171: 
   172:         WORD    Window;                 // Local free RX buffer window
   173:         WORD    Checksum;               // Data payload checksum
   174:         WORD    UrgentPointer;  // Urgent pointer
   175: } TCP_HEADER;
   176: 
   177: #define TCP_OPTIONS_END_OF_LIST     (0x00u)             // End of List TCP Option Flag
   178: #define TCP_OPTIONS_NO_OP           (0x01u)             // No Op TCP Option
   179: #define TCP_OPTIONS_MAX_SEG_SIZE    (0x02u)             // Maximum segment size TCP flag
   180: typedef struct
   181: {
   182:         BYTE        Kind;                                                       // Type of option
   183:         BYTE        Length;                                                     // Length
   184:         WORD_VAL    MaxSegSize;                                         // Maximum segment size
   185: } TCP_OPTIONS;                                                                  // TCP Options data structure                                                   
   186: 
   187: // Structure containing all the important elements of an incomming 
   188: // SYN packet in order to establish a connection at a future time 
   189: // if all sockets on the listening port are already connected to 
   190: // someone
   191: typedef struct 
   192: {
   193:         NODE_INFO       niSourceAddress;// Remote IP address and MAC address
   194:         WORD            wSourcePort;    // Remote TCP port number that the response SYN needs to be sent to
   195:         DWORD           dwSourceSEQ;    // Remote TCP SEQuence number that must be ACKnowledged when we send our response SYN
   196:         WORD            wDestPort;              // Local TCP port which the original SYN was destined for
   197:         WORD            wTimestamp;             // Timer to expire old SYN packets that can't be serviced at all
   198: } TCP_SYN_QUEUE;
   199: 
   200: 
   201: #if defined(STACK_CLIENT_MODE)
   202: static WORD NextPort __attribute__((persistent));       // Tracking variable for next local client port number
   203: #endif
   204: 
   205: /****************************************************************************
   206:   Section:
   207:         TCB Definitions
   208:   ***************************************************************************/
   209: 
   210: // Determines the number of defined TCP sockets
   211: #define TCP_SOCKET_COUNT        (sizeof(TCPSocketInitializer)/sizeof(TCPSocketInitializer[0]))
   212: 
   213: 
   214: #if defined(HI_TECH_C)
   215:         // The initializer forces this large array out of the bss section 
   216:         // so we can link correctly.
   217:         #pragma psect bigdata=TCB_uRAM_BIG
   218:         #pragma psect data=TCB_uRAM
   219:         static TCB_STUB TCBStubs[TCP_SOCKET_COUNT] = {'\0'};    
   220:         #pragma psect data=ordinary_data_sect
   221:         #pragma psect bigdata=ordinary_data_sect_big
   222: #else
   223:         // The TCB array is very large.  With the C18 compiler, one must 
   224:         // modify the linker script to make an array that spans more than 
   225:         // one memory bank.  To do this, make the necessary changes to your 
   226:         // processor's linker script (.lkr).  Here is an example showing 
   227:         // gpr11 and 128 bytes of gpr12 being combined into one 384 byte 
   228:         // block used exclusively by the TCB_uRAM data section:
   229:         // ...
   230:         // //DATABANK   NAME=gpr11      START=0xB00          END=0xBFF
   231:         // //DATABANK   NAME=gpr12      START=0xC00          END=0xCFF
   232:         // DATABANK   NAME=gpr11b     START=0xB00          END=0xC7F           PROTECTED
   233:         // DATABANK   NAME=gpr12      START=0xC80          END=0xCFF
   234:         // ...
   235:         // SECTION    NAME=TCB_uRAM    RAM=gpr11b
   236:         // ...
   237:         #if defined(__18CXX) && !defined(HI_TECH_C)     
   238:                 #pragma udata TCB_uRAM
   239:         #endif
   240:         static TCB_STUB TCBStubs[TCP_SOCKET_COUNT];
   241:         #if defined(__18CXX) && !defined(HI_TECH_C)     
   242:                 #pragma udata                                   // Return to any other RAM section
   243:         #endif
   244: #endif
   245: 
   246: static TCB MyTCB;                                                                       // Currently loaded TCB
   247: static TCP_SOCKET hCurrentTCP = INVALID_SOCKET;         // Current TCP socket
   248: #if TCP_SYN_QUEUE_MAX_ENTRIES
   249:         #if defined(__18CXX) && !defined(HI_TECH_C)     
   250:                 #pragma udata SYN_QUEUE_RAM_SECT
   251:         #endif
   252:         static TCP_SYN_QUEUE SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES];       // Array of saved incoming SYN requests that need to be serviced later
   253:         #if defined(__18CXX) && !defined(HI_TECH_C)     
   254:                 #pragma udata
   255:         #endif
   256: #endif
   257: 
   258: /****************************************************************************
   259:   Section:
   260:         Function Prototypes
   261:   ***************************************************************************/
   262: 
   263: static void TCPRAMCopy(PTR_BASE wDest, BYTE vDestType, PTR_BASE wSource, BYTE vSourceType, WORD wLength);
   264: 
   265: #if defined(__18CXX)
   266:         static void TCPRAMCopyROM(PTR_BASE wDest, BYTE wDestType, ROM BYTE* wSource, WORD wLength);
   267: #else
   268:         #define TCPRAMCopyROM(a,b,c,d)  TCPRAMCopy(a,b,c,TCP_PIC_RAM,d)
   269: #endif
   270: 
   271: static void SendTCP(BYTE vTCPFlags, BYTE vSendFlags);
   272: static void HandleTCPSeg(TCP_HEADER* h, WORD len);
   273: static BOOL FindMatchingSocket(TCP_HEADER* h, NODE_INFO* remote);
   274: static void SwapTCPHeader(TCP_HEADER* header);
   275: static void CloseSocket(void);
   276: static void SyncTCB(void);
   277: 
   278: // Indicates if this packet is a retransmission (no reset) or a new packet (reset required)
   279: #define SENDTCP_RESET_TIMERS    0x01
   280: // Instead of transmitting normal data, a garbage octet is transmitted according to RFC 1122 section 4.2.3.6
   281: #define SENDTCP_KEEP_ALIVE              0x02
   282: 
   283: 
   284: /****************************************************************************
   285:   Section:
   286:         TCB Optimization Configuration
   287:   ***************************************************************************/
   288: 
   289: #if defined(TCP_OPTIMIZE_FOR_SIZE)
   290:         static TCB_STUB MyTCBStub;
   291:         
   292:         // Flushes MyTCBStub cache and loads up the specified TCB_STUB.
   293:         // Does nothing on cache hit.
   294:         static void SyncTCBStub(TCP_SOCKET hTCP)
   295:         {
   296:                 if(hCurrentTCP == hTCP)
   297:                         return;
   298:         
   299:                 if(hCurrentTCP != INVALID_SOCKET)
   300:                 {
   301:                         // Save the current TCB stub
   302:                         memcpy((void*)&TCBStubs[hCurrentTCP], (void*)&MyTCBStub, sizeof(MyTCBStub));
   303:                 }
   304:         
   305:                 hCurrentTCP = hTCP;
   306:         
   307:                 if(hTCP == INVALID_SOCKET)
   308:                         return;
   309:         
   310:                 // Load up the new TCB stub
   311:                 memcpy((void*)&MyTCBStub, (void*)&TCBStubs[hTCP], sizeof(MyTCBStub));
   312:         }
   313: #else
   314:         // Flushes MyTCBStub cache and loads up the specified TCB_STUB.
   315:         // Does nothing on cache hit.
   316:         #define SyncTCBStub(a)  hCurrentTCP = (a)
   317:         // Alias to current TCP stub.
   318:         #define MyTCBStub               TCBStubs[hCurrentTCP]
   319: #endif
   320: 
   321: 
   322: 
   323: // Flushes MyTCB cache and loads up the specified TCB.
   324: // Does nothing on cache hit.
   325: static void SyncTCB(void)
   326: {
   327:         static TCP_SOCKET hLastTCB = INVALID_SOCKET;
   328:         
   329:         if(hLastTCB == hCurrentTCP)
   330:                 return;
   331: 
   332:         if(hLastTCB != INVALID_SOCKET)
   333:         {
   334:                 // Save the current TCB
   335:                 TCPRAMCopy(TCBStubs[hLastTCB].bufferTxStart - sizeof(MyTCB), TCBStubs[hLastTCB].vMemoryMedium, (PTR_BASE)&MyTCB, TCP_PIC_RAM, sizeof(MyTCB));
   336:         }
   337: 
   338:         // Load up the new TCB
   339:         hLastTCB = hCurrentTCP;
   340:         TCPRAMCopy((PTR_BASE)&MyTCB, TCP_PIC_RAM, MyTCBStub.bufferTxStart - sizeof(MyTCB), MyTCBStub.vMemoryMedium, sizeof(MyTCB));
   341: }
   342: 
   343: 
   344: /*****************************************************************************
   345:   Function:
   346:         void TCPInit(void)
   347: 
   348:   Summary:
   349:         Initializes the TCP module.
   350: 
   351:   Description:
   352:         Initializes the TCP module.  This function sets up the TCP buffers
   353:         in memory and initializes each socket to the CLOSED state.  If
   354:         insufficient memory was allocated for the TCP sockets, the function
   355:         will hang here to be captured by the debugger.
   356: 
   357:   Precondition:
   358:         None
   359: 
   360:   Parameters:
   361:         None
   362: 
   363:   Returns:
   364:         None
   365:         
   366:   Remarks:
   367:         This function is called only one during lifetime of the application.
   368:   ***************************************************************************/
   369: void TCPInit(void)
   370: {
   371:         BYTE i;
   372:         BYTE vSocketsAllocated;
   373:         WORD wTXSize, wRXSize;
   374:         PTR_BASE ptrBaseAddress;
   375:         BYTE vMedium;
   376:         #if TCP_ETH_RAM_SIZE > 0
   377:         WORD wCurrentETHAddress = TCP_ETH_RAM_BASE_ADDRESS;
   378:         #endif
   379:         #if TCP_PIC_RAM_SIZE > 0
   380:         PTR_BASE ptrCurrentPICAddress = TCP_PIC_RAM_BASE_ADDRESS;
   381:         #endif
   382:         #if TCP_SPI_RAM_SIZE > 0
   383:         WORD wCurrentSPIAddress = TCP_SPI_RAM_BASE_ADDRESS;
   384:         #endif
   385: 
   386:         #if defined(STACK_CLIENT_MODE)
   387:                 // Initialize NextPort to a random value if it is zero (such as after 
   388:                 // reset on a PIC32 or PIC18 when the static memory initializer is 
   389:                 // used).  By starting with a random number, we decrease the risk of 
   390:                 // reusing a port number that was previously used if the user power 
   391:                 // cycles the device.
   392:                 if(NextPort == 0u)
   393:                         NextPort = (((WORD)GenerateRandomDWORD()) & 0x07FFu) + LOCAL_PORT_START_NUMBER;
   394:         #endif
   395: 
   396: 
   397:         // Mark all SYN Queue entries as invalid by zeroing the memory
   398:         #if TCP_SYN_QUEUE_MAX_ENTRIES
   399:                 memset((void*)SYNQueue, 0x00, sizeof(SYNQueue));
   400:         #endif
   401:         
   402:         // Allocate all socket FIFO addresses
   403:         vSocketsAllocated = 0;
   404:         for(i = 0; i < TCP_SOCKET_COUNT; i++)
   405:         {
   406:                 // Generate all needed sockets of each type (TCP_PURPOSE_*)
   407:                 SyncTCBStub(i);
   408:         
   409:                 vMedium = TCPSocketInitializer[i].vMemoryMedium;
   410:                 wTXSize = TCPSocketInitializer[i].wTXBufferSize;
   411:                 wRXSize = TCPSocketInitializer[i].wRXBufferSize;
   412:         
   413:                 switch(vMedium)
   414:                 {
   415:                         #if TCP_ETH_RAM_SIZE > 0
   416:                         case TCP_ETH_RAM:
   417:                                 ptrBaseAddress = wCurrentETHAddress;
   418:                                 wCurrentETHAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1;
   419:                                 // Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us.
   420:                                 // If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in TCPIPConfig.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken.
   421:                                 while(wCurrentETHAddress > TCP_ETH_RAM_BASE_ADDRESS + TCP_ETH_RAM_SIZE);
   422:                                 break;
   423:                         #endif
   424:                                 
   425:                         #if TCP_PIC_RAM_SIZE > 0
   426:                         case TCP_PIC_RAM:
   427:                                 ptrBaseAddress = ptrCurrentPICAddress;
   428:                                 ptrCurrentPICAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1;
   429:                                 // Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us.
   430:                                 // If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in TCPIPConfig.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken.
   431:                                 while(ptrCurrentPICAddress > TCP_PIC_RAM_BASE_ADDRESS + TCP_PIC_RAM_SIZE);
   432:                                 break;
   433:                         #endif
   434:                                 
   435:                         #if TCP_SPI_RAM_SIZE > 0
   436:                         case TCP_SPI_RAM:
   437:                                 ptrBaseAddress = wCurrentSPIAddress;
   438:                                 wCurrentSPIAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1;
   439:                                 // Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us.
   440:                                 // If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in TCPIPConfig.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken.
   441:                                 while(wCurrentSPIAddress > TCP_SPI_RAM_BASE_ADDRESS + TCP_SPI_RAM_SIZE);
   442:                                 break;
   443:                         #endif
   444:                         
   445:                         default:
   446:                                 while(1); // Undefined allocation medium.  Go fix your TCPIPConfig.h TCP memory allocations.
   447:                 }
   448:         
   449:                 MyTCBStub.vMemoryMedium = vMedium;
   450:                 MyTCBStub.bufferTxStart = ptrBaseAddress + sizeof(TCB);
   451:                 MyTCBStub.bufferRxStart = MyTCBStub.bufferTxStart + wTXSize + 1;
   452:                 MyTCBStub.bufferEnd             = MyTCBStub.bufferRxStart + wRXSize;
   453:                 MyTCBStub.smState               = TCP_CLOSED;
   454:                 MyTCBStub.Flags.bServer = FALSE;
   455:                 #if defined(STACK_USE_SSL)
   456:                 MyTCBStub.sslStubID = SSL_INVALID_ID;
   457:                 #endif          
   458: 
   459:                 SyncTCB();
   460:                 MyTCB.vSocketPurpose = TCPSocketInitializer[i].vSocketPurpose;
   461:                 CloseSocket();
   462:         }
   463: }
   464: 
   465: /****************************************************************************
   466:   Section:
   467:         Connection Management Functions
   468:   ***************************************************************************/
   469: 
   470: 
   471: /*****************************************************************************
   472:   Function:
   473:         TCP_SOCKET TCPOpen(DWORD dwRemoteHost, BYTE vRemoteHostType, WORD wPort, BYTE vSocketPurpose)
   474:     
   475:   Summary:
   476:     Opens a TCP socket for listening or as a client.
   477: 
   478:   Description:
   479:     Provides a unified method for opening TCP sockets. This function can
   480:     open both client and server sockets. For client sockets, it can accept
   481:     a host name string to query in DNS, an IP address as a string, an IP
   482:     address in binary form, or a previously resolved NODE_INFO structure
   483:     containing the remote IP address and associated MAC address. When a
   484:     host name or IP address only is provided, the TCP module will
   485:     internally perform the necessary DNS and/or ARP resolution steps before
   486:     reporting that the TCP socket is connected (via a call to
   487:     TCPISConnected returning TRUE). Server sockets ignore this destination
   488:     parameter and listen only on the indicated port.
   489:     
   490:     The vSocketPurpose field allows sockets to be opened with varying
   491:     buffer size parameters and memory storage mediums. This field
   492:     corresponds to pre-defined sockets allocated in the
   493:     TCPSocketInitializer[] array in TCPIPConfig.h. The TCPIPConfig.h file
   494:     can be edited using the TCP/IP Configuration Wizard.
   495:     
   496:     Sockets are statically allocated on boot, but can be claimed with this
   497:     \function and freed using TCPDisconnect or TCPClose (for client
   498:     sockets). Server sockets can be freed using TCPClose only (calls to
   499:     TCPDisconnect will return server sockets to the listening state,
   500:     allowing reuse).
   501: 
   502:   Conditions:
   503:     TCP is initialized.
   504: 
   505:   Input:
   506:     dwRemoteHost -     For client sockets only. Provide a pointer to a
   507:                        null\-terminated string of the remote host name (ex\:
   508:                        "www.microchip.com" or "192.168.1.123"), a literal
   509:                        destination IP address (ex\: 0x7B01A8C0 or an IP_ADDR
   510:                        data type), or a pointer to a NODE_INFO structure
   511:                        with the remote IP address and remote node or gateway
   512:                        MAC address specified. If a string is provided, note
   513:                        that it must be statically allocated in memory and
   514:                        cannot be modified or deallocated until
   515:                        TCPIsConnected returns TRUE.<p />This parameter is
   516:                        ignored for server sockets.
   517:     vRemoteHostType -  Any one of the following flags to identify the
   518:                        meaning of the dwRemoteHost parameter\:
   519:                        * TCP_OPEN_SERVER &#45; Open a server socket and
   520:                          ignore the dwRemoteHost parameter.
   521:                        * TCP_OPEN_RAM_HOST &#45; Open a client socket and
   522:                          connect it to a remote host who's name is stored as a
   523:                          null terminated string in a RAM array. Ex\:
   524:                          "www.microchip.com" or "192.168.0.123" (BYTE&#42;
   525:                          type)
   526:                        * TCP_OPEN_ROM_HOST &#45; Open a client socket and
   527:                          connect it to a remote host who's name is stored as a
   528:                          null terminated string in a literal string or ROM
   529:                          array. Ex\: "www.microchip.com" or "192.168.0.123"
   530:                          (ROM BYTE&#42; type)
   531:                        * TCP_OPEN_IP_ADDRESS &#45; Open a client socket and
   532:                          connect it to a remote IP address. Ex\: 0x7B01A8C0
   533:                          for 192.168.1.123 (DWORD type). Note that the byte
   534:                          ordering is big endian.
   535:                        * TCP_OPEN_NODE_INFO &#45; Open a client socket and
   536:                          connect it to a remote IP and MAC addresses pair
   537:                          stored in a NODE_INFO structure. dwRemoteHost must be
   538:                          a pointer to the NODE_INFO structure. This option is
   539:                          provided for backwards compatibility with
   540:                          applications built against prior stack versions that
   541:                          only implemented the TCPConnect() function. It can
   542:                          also be used to skip DNS and ARP resolution steps if
   543:                          connecting to a remote node which you've already
   544:                          connected to and have cached addresses for.
   545:     wPort -            TCP port to listen on or connect to\:
   546:                        * Client sockets &#45; the remote TCP port to which a
   547:                          connection should be made. The local port for client
   548:                          sockets will be automatically picked by the TCP
   549:                          module.
   550:                        * Server sockets &#45; the local TCP port on which to
   551:                          listen for connections.
   552:     vSocketPurpose -   Any of the TCP_PURPOSE_* constants defined in
   553:                        TCPIPConfig.h or the TCPIPConfig utility (see
   554:                        TCPSocketInitializer[] array).
   555: 
   556:   Return Values:
   557:     INVALID_SOCKET -  No sockets of the specified type were available to be
   558:                       opened.
   559:     Otherwise -       A TCP_SOCKET handle. Save this handle and use it when
   560:                       calling all other TCP APIs.
   561: 
   562:   Remarks:
   563:     This function replaces the old TCPConnect and TCPListen functions.
   564:     
   565:     If TCP_OPEN_RAM_HOST or TCP_OPEN_ROM_HOST are used for the destination
   566:     type, the DNS client module must also be enabled (STACK_USE_DNS must be
   567:     defined in TCPIPConfig.h).
   568: 
   569:   Example:
   570:     \ \ 
   571:     <code>
   572:     // Open a server socket
   573:     skt = TCPOpen(NULL, TCP_OPEN_SERVER, HTTP_PORT, TCP_PURPOSE_HTTP_SERVER);
   574:     
   575:     // Open a client socket to www.microchip.com
   576:     // The double cast here prevents compiler warnings
   577:     skt = TCPOpen((DWORD)(PTR_BASE)"www.microchip.com",
   578:                     TCP_OPEN_ROM_HOST, 80, TCP_PURPOSE_DEFAULT);
   579:     
   580:     // Reopen a client socket without repeating DNS or ARP
   581:     SOCKET_INFO cache = TCPGetSocketInfo(skt);  // Call with the old socket
   582:     skt = TCPOpen((DWORD)(PTR_BASE)&amp;cache.remote, TCP_OPEN_NODE_INFO,
   583:                     cache.remotePort.Val, TCP_PURPOSE_DEFAULT);
   584:     </code>                                                    
   585:   *****************************************************************************/
   586: TCP_SOCKET TCPOpen(DWORD dwRemoteHost, BYTE vRemoteHostType, WORD wPort, BYTE vSocketPurpose)
   587: {
   588:         TCP_SOCKET hTCP;
   589: 
   590:         // Find an available socket that matches the specified socket type
   591:         for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++)
   592:         {
   593:                 SyncTCBStub(hTCP);
   594: 
   595:                 // Sockets that are in use will be in a non-closed state
   596:                 if(MyTCBStub.smState != TCP_CLOSED)
   597:                         continue;
   598: 
   599:                 SyncTCB();
   600: 
   601:                 // See if this socket matches the desired type
   602:                 if(MyTCB.vSocketPurpose != vSocketPurpose)
   603:                         continue;
   604: 
   605:                 // Start out assuming worst case Maximum Segment Size (changes when MSS 
   606:                 // option is received from remote node)
   607:                 MyTCB.wRemoteMSS = 536;
   608: 
   609:                 // See if this is a server socket
   610:                 if(vRemoteHostType == TCP_OPEN_SERVER)
   611:                 {
   612:                         MyTCB.localPort.Val = wPort;
   613:                         MyTCBStub.Flags.bServer = TRUE;
   614:                         MyTCBStub.smState = TCP_LISTEN;
   615:                         MyTCBStub.remoteHash.Val = wPort;
   616:                         #if defined(STACK_USE_SSL_SERVER)
   617:                         MyTCB.localSSLPort.Val = 0;
   618:                         #endif
   619:                 }
   620:                 // Handle all the client mode socket types
   621:                 else
   622:                 {
   623:                         #if defined(STACK_CLIENT_MODE)
   624:                         {
   625:                                 // Each new socket that is opened by this node, gets the 
   626:                                 // next sequential local port number.
   627:                                 if(NextPort < LOCAL_PORT_START_NUMBER || NextPort > LOCAL_PORT_END_NUMBER)
   628:                                         NextPort = LOCAL_PORT_START_NUMBER;
   629:                                 
   630:                                 // Set the non-zero TCB fields
   631:                                 MyTCB.localPort.Val = NextPort++;
   632:                                 MyTCB.remotePort.Val = wPort;
   633:         
   634:                                 // Flag to start the DNS, ARP, SYN processes
   635:                                 MyTCBStub.eventTime = TickGet();
   636:                                 MyTCBStub.Flags.bTimerEnabled = 1;
   637:         
   638:                                 switch(vRemoteHostType)
   639:                                 {
   640:                                         #if defined(STACK_USE_DNS)
   641:                                         case TCP_OPEN_RAM_HOST:
   642:                                         case TCP_OPEN_ROM_HOST:
   643:                                                 MyTCB.remote.dwRemoteHost = dwRemoteHost;
   644:                                                 MyTCB.flags.bRemoteHostIsROM = (vRemoteHostType == TCP_OPEN_ROM_HOST);
   645:                                                 MyTCBStub.smState = TCP_GET_DNS_MODULE;
   646:                                                 break;
   647:                                         #endif
   648:                 
   649:                                         case TCP_OPEN_IP_ADDRESS:
   650:                                                 // dwRemoteHost is a literal IP address.  This 
   651:                                                 // doesn't need DNS and can skip directly to the 
   652:                                                 // Gateway ARPing step.
   653:                                                 MyTCBStub.remoteHash.Val = (((DWORD_VAL*)&dwRemoteHost)->w[1]+((DWORD_VAL*)&dwRemoteHost)->w[0] + wPort) ^ MyTCB.localPort.Val;
   654:                                                 MyTCB.remote.niRemoteMACIP.IPAddr.Val = dwRemoteHost;
   655:                                                 MyTCB.retryCount = 0;
   656:                                                 MyTCB.retryInterval = (TICK_SECOND/4)/256;
   657:                                                 MyTCBStub.smState = TCP_GATEWAY_SEND_ARP;
   658:                                                 break;
   659:                 
   660:                                         case TCP_OPEN_NODE_INFO:
   661:                                                 MyTCBStub.remoteHash.Val = (((NODE_INFO*)(PTR_BASE)dwRemoteHost)->IPAddr.w[1]+((NODE_INFO*)(PTR_BASE)dwRemoteHost)->IPAddr.w[0] + wPort) ^ MyTCB.localPort.Val;
   662:                                                 memcpy((void*)(BYTE*)&MyTCB.remote, (void*)(BYTE*)(PTR_BASE)dwRemoteHost, sizeof(NODE_INFO));
   663:                                                 MyTCBStub.smState = TCP_SYN_SENT;
   664:                                                 SendTCP(SYN, SENDTCP_RESET_TIMERS);
   665:                                                 break;
   666:                                 }
   667:                         }               
   668:                         #else
   669:                         {
   670:                                 return INVALID_SOCKET;
   671:                         }       
   672:                         #endif
   673:                 }
   674:                 
   675:                 return hTCP;            
   676:         }
   677: 
   678:         // If there is no socket available, return error.
   679:         return INVALID_SOCKET;
   680: }
   681: 
   682: 
   683: /*****************************************************************************
   684:   Function:
   685:         BOOL TCPWasReset(TCP_SOCKET hTCP)
   686: 
   687:   Summary:
   688:         Self-clearing semaphore inidicating socket reset.
   689: 
   690:   Description:
   691:         This function is a self-clearing semaphore indicating whether or not
   692:         a socket has been disconnected since the previous call.  This function
   693:         works for all possible disconnections: a call to TCPDisconnect, a FIN 
   694:         from the remote node, or an acknowledgement timeout caused by the loss
   695:         of a network link.  It also returns TRUE after the first call to TCPInit.
   696:         Applications should use this function to reset their state machines.
   697:         
   698:         This function was added due to the possibility of an error when relying
   699:         on TCPIsConnected returing FALSE to check for a condition requiring a
   700:         state machine reset.  If a socket is closed (due to a FIN ACK) and then
   701:         immediately reopened (due to a the arrival of a new SYN) in the same
   702:         cycle of the stack, calls to TCPIsConnected by the application will 
   703:         never return FALSE even though the socket has been disconnected.  This 
   704:         can cause errors for protocols such as HTTP in which a client will 
   705:         immediately open a new connection upon closing of a prior one.  Relying
   706:         on this function instead allows applications to trap those conditions 
   707:         and properly reset their internal state for the new connection.
   708: 
   709:   Precondition:
   710:         TCP is initialized.
   711: 
   712:   Parameters:
   713:         hTCP - The socket to check.
   714: 
   715:   Return Values:
   716:         TRUE - The socket has been disconnected since the previous call.
   717:         FALSE - The socket has not been disconnected since the previous call.
   718:   ***************************************************************************/
   719: BOOL TCPWasReset(TCP_SOCKET hTCP)
   720: {
   721:         if(hTCP >= TCP_SOCKET_COUNT)
   722:     {
   723:         return TRUE;
   724:     }
   725:     
   726:         SyncTCBStub(hTCP);
   727:         
   728:         if(MyTCBStub.Flags.bSocketReset)
   729:         {
   730:                 MyTCBStub.Flags.bSocketReset = 0;
   731:                 return TRUE;
   732:         }       
   733:         
   734:         return FALSE;
   735: }
   736: 
   737: 
   738: /*****************************************************************************
   739:   Function:
   740:         BOOL TCPIsConnected(TCP_SOCKET hTCP)
   741: 
   742:   Summary:
   743:         Determines if a socket has an established connection.
   744: 
   745:   Description:
   746:         This function determines if a socket has an established connection to 
   747:         a remote node.  Call this function after calling TCPOpen to determine 
   748:         when the connection is set up and ready for use.  This function was 
   749:         historically used to check for disconnections, but TCPWasReset is now a
   750:         more appropriate solution. 
   751: 
   752:   Precondition:
   753:         TCP is initialized.
   754: 
   755:   Parameters:
   756:         hTCP - The socket to check.
   757: 
   758:   Return Values:
   759:         TRUE - The socket has an established connection to a remote node.
   760:         FALSE - The socket is not currently connected.
   761: 
   762:   Remarks:
   763:         A socket is said to be connected only if it is in the TCP_ESTABLISHED
   764:         state.  Sockets in the process of opening or closing will return FALSE.
   765:   ***************************************************************************/
   766: BOOL TCPIsConnected(TCP_SOCKET hTCP)
   767: {
   768:         if(hTCP >= TCP_SOCKET_COUNT)
   769:     {
   770:         return FALSE;
   771:     }
   772:     
   773:         SyncTCBStub(hTCP);
   774:         return (MyTCBStub.smState == TCP_ESTABLISHED);
   775: }
   776: 
   777: 
   778: /*****************************************************************************
   779:   Function:
   780:         void TCPDisconnect(TCP_SOCKET hTCP)
   781: 
   782:   Summary:
   783:         Disconnects an open socket.
   784: 
   785:   Description:
   786:         This function closes a connection to a remote node by sending a FIN (if 
   787:         currently connected).
   788:         
   789:         The function can be called a second time to force a socket closed by 
   790:         sending a RST packet.  This is useful when the application knows that 
   791:         the remote node will not send an ACK (if it has crashed or lost its link),
   792:         or when the application needs to reuse the socket immediately regardless
   793:         of whether or not the remote node would like to transmit more data before
   794:         closing.
   795:         
   796:         For client mode sockets, upon return, the hTCP handle is relinquished to 
   797:         the TCP/IP stack and must no longer be used by the application (except for 
   798:         an immediate subsequent call to TCPDisconnect() to force a RST 
   799:         transmission, if needed).  
   800:         
   801:         For server mode sockets, upon return, the hTCP handle is NOT relinquished 
   802:         to the TCP/IP stack.  After closing, the socket returns to the listening 
   803:         state allowing future connection requests to be serviced.  This leaves the 
   804:         hTCP handle in a valid state and must be retained for future operations on 
   805:         the socket.  If you want to close the server and relinquish the socket back 
   806:         to the TCP/IP stack, call the TCPClose() API instead of TCPDisconnect().
   807: 
   808:   Precondition:
   809:         None
   810: 
   811:   Parameters:
   812:         hTCP - Handle of the socket to disconnect.
   813: 
   814:   Returns:
   815:         None
   816: 
   817:   Remarks:
   818:         If the socket is using SSL, a CLOSE_NOTIFY record will be transmitted
   819:         first to allow the SSL session to be resumed at a later time.
   820:   ***************************************************************************/
   821: void TCPDisconnect(TCP_SOCKET hTCP)
   822: {
   823:         if(hTCP >= TCP_SOCKET_COUNT)
   824:     {
   825:         return;
   826:     }
   827:     
   828:         SyncTCBStub(hTCP);
   829: 
   830:         // Delete all data in the RX FIFO
   831:         // In this stack's API, the application TCP handle is 
   832:         // immediately invalid after calling this function, so there 
   833:         // is no longer any way to receive data from the TCP RX FIFO, 
   834:         // even though the data is still there.  Leaving the data there 
   835:         // could interfere with the remote node sending us a FIN if our
   836:         // RX window is zero
   837:         MyTCBStub.rxTail = MyTCBStub.rxHead;
   838: 
   839:         switch(MyTCBStub.smState)
   840:         {
   841:                 #if defined(STACK_CLIENT_MODE) && defined(STACK_USE_DNS)
   842:                 case TCP_DNS_RESOLVE:
   843:                         DNSEndUsage();  // Release the DNS module, since the user is aborting
   844:                         CloseSocket();
   845:                         break;
   846:                 #endif
   847: 
   848:                 case TCP_GET_DNS_MODULE:
   849:                 case TCP_GATEWAY_SEND_ARP:
   850:                 case TCP_GATEWAY_GET_ARP:
   851:                 case TCP_SYN_SENT:
   852:                         CloseSocket();
   853:                         break;
   854: 
   855:                 case TCP_SYN_RECEIVED:
   856:                 case TCP_ESTABLISHED:
   857:                         #if defined(STACK_USE_SSL)
   858:                         // When disconnecting SSL sockets, send a close_notify so we can resume later
   859:                         if(MyTCBStub.sslStubID != SSL_INVALID_ID)
   860:                         {
   861:                                 // Flush pending data and send close_notify
   862:                                 SSLTxRecord(hTCP, MyTCBStub.sslStubID, SSL_APPLICATION);
   863:                                 SSLTxMessage(hTCP, MyTCBStub.sslStubID, SSL_ALERT_CLOSE_NOTIFY);
   864:                         }
   865:                         #endif
   866: 
   867:                         // Send the FIN.  This is done in a loop to ensure that if we have 
   868:                         // more data wating in the TX FIFO than can be sent in a single 
   869:                         // packet (due to the remote Max Segment Size packet size limit), 
   870:                         // we will keep generating more packets until either all data gets 
   871:                         // transmitted or the remote node's receive window fills up.
   872:                         do
   873:                         {
   874:                                 SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS);
   875:                                 if(MyTCB.remoteWindow == 0u)
   876:                                         break;
   877:                         } while(MyTCBStub.txHead != MyTCB.txUnackedTail);
   878:                         
   879:                         MyTCBStub.smState = TCP_FIN_WAIT_1;
   880:                         break;
   881: 
   882:                 case TCP_CLOSE_WAIT:
   883:                         // Send the FIN.  This is done in a loop to ensure that if we have 
   884:                         // more data wating in the TX FIFO than can be sent in a single 
   885:                         // packet (due to the remote Max Segment Size packet size limit), 
   886:                         // we will keep generating more packets until either all data gets 
   887:                         // transmitted or the remote node's receive window fills up.
   888:                         do
   889:                         {
   890:                                 SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS);
   891:                                 if(MyTCB.remoteWindow == 0u)
   892:                                         break;
   893:                         } while(MyTCBStub.txHead != MyTCB.txUnackedTail);
   894: 
   895:                         MyTCBStub.smState = TCP_LAST_ACK;
   896:                         break;
   897:                         
   898:                 // These states are all already closed or don't need explicit disconnecting -- they will disconnect by themselves after a while
   899:                 //case TCP_CLOSED:
   900:                 //case TCP_LISTEN:
   901:                 //case TCP_CLOSING:
   902:                 //case TCP_TIME_WAIT:
   903:                 //      return;
   904: 
   905:                 case TCP_CLOSED_BUT_RESERVED:
   906:                         MyTCBStub.smState = TCP_CLOSED;
   907:                         break;
   908: 
   909:                 // These states will close themselves after some delay, however, 
   910:                 // this is handled so that the user can call TCPDisconnect() 
   911:                 // twice to immediately close a socket (using an RST) without 
   912:                 // having to get an ACK back from the remote node.  This is 
   913:                 // great for instance when the application determines that 
   914:                 // the remote node has been physically disconnected and 
   915:                 // already knows that no ACK will be returned.  Alternatively, 
   916:                 // if the application needs to immediately reuse the socket 
   917:                 // regardless of what the other node's state is in (half open).
   918:                 case TCP_FIN_WAIT_1:
   919:                 case TCP_FIN_WAIT_2:
   920:                 case TCP_LAST_ACK:
   921:                 default:
   922:                         SendTCP(RST | ACK, 0);
   923:                         CloseSocket();
   924:                         break;
   925:         }
   926: }
   927: 
   928: 
   929: /*****************************************************************************
   930:   Function:
   931:         void TCPClose(TCP_SOCKET hTCP)
   932: 
   933:   Summary:
   934:         Disconnects an open socket and destroys the socket handle, including server 
   935:         mode socket handles.
   936: 
   937:   Description:
   938:         Disconnects an open socket and destroys the socket handle, including server 
   939:         mode socket handles.  This function performs identically to the 
   940:         TCPDisconnect() function, except that both client and server mode socket 
   941:         handles are relinquished to the TCP/IP stack upon return.
   942: 
   943:   Precondition:
   944:         None
   945: 
   946:   Parameters:
   947:         hTCP - Handle to the socket to disconnect and close.
   948: 
   949:   Returns:
   950:         None
   951:   ***************************************************************************/
   952: void TCPClose(TCP_SOCKET hTCP)
   953: {
   954:         if(hTCP >= TCP_SOCKET_COUNT)
   955:     {
   956:         return;
   957:     }
   958:     
   959:         SyncTCBStub(hTCP);
   960:         MyTCBStub.Flags.bServer = FALSE;
   961:         TCPDisconnect(hTCP);
   962: }
   963: 
   964: 
   965: /*****************************************************************************
   966:   Function:
   967:         SOCKET_INFO* TCPGetRemoteInfo(TCP_SOCKET hTCP)
   968: 
   969:   Summary:
   970:         Obtains information about a currently open socket.
   971: 
   972:   Description:
   973:         Returns the SOCKET_INFO structure associated with this socket.  This 
   974:         contains the NODE_INFO structure with IP and MAC address (or gateway
   975:         MAC) and the remote port.
   976: 
   977:   Precondition:
   978:         TCP is initialized and the socket is connected.
   979: 
   980:   Parameters:
   981:         hTCP - The socket to check.
   982: 
   983:   Returns:
   984:         The SOCKET_INFO structure associated with this socket.  This structure is 
   985:         allocated statically by the function and is valid only until the next 
   986:         time TCPGetRemoteInfo() is called.
   987:   ***************************************************************************/
   988: SOCKET_INFO* TCPGetRemoteInfo(TCP_SOCKET hTCP)
   989: {
   990:         static SOCKET_INFO      RemoteInfo;
   991: 
   992:         if(hTCP >= TCP_SOCKET_COUNT)
   993:     {
   994:         return 0;
   995:     }
   996:     
   997:         SyncTCBStub(hTCP);
   998:         SyncTCB();
   999:         memcpy((void*)&RemoteInfo.remote, (void*)&MyTCB.remote, sizeof(NODE_INFO));
  1000:         RemoteInfo.remotePort.Val = MyTCB.remotePort.Val;
  1001: 
  1002:         return &RemoteInfo;
  1003: }
  1004: 
  1005: 
  1006: 
  1007: /****************************************************************************
  1008:   Section:
  1009:         Transmit Functions
  1010:   ***************************************************************************/
  1011: 
  1012: /*****************************************************************************
  1013:   Function:
  1014:         void TCPFlush(TCP_SOCKET hTCP)
  1015: 
  1016:   Summary:
  1017:         Immediately transmits all pending TX data.
  1018: 
  1019:   Description:
  1020:         This function immediately transmits all pending TX data with a PSH 
  1021:         flag.  If this function is not called, data will automatically be sent
  1022:         when either a) the TX buffer is half full or b) the 
  1023:         TCP_AUTO_TRANSMIT_TIMEOUT_VAL (default: 40ms) has elapsed.
  1024: 
  1025:   Precondition:
  1026:         TCP is initialized and the socket is connected.
  1027: 
  1028:   Parameters:
  1029:         hTCP - The socket whose data is to be transmitted.
  1030: 
  1031:   Returns:
  1032:         None
  1033: 
  1034:   Remarks:
  1035:         SSL application data is automatically flushed, so this function has 
  1036:         no effect for SSL sockets.
  1037:   ***************************************************************************/
  1038: void TCPFlush(TCP_SOCKET hTCP)
  1039: {
  1040:         if(hTCP >= TCP_SOCKET_COUNT)
  1041:     {
  1042:         return;
  1043:     }
  1044:     
  1045:         SyncTCBStub(hTCP);
  1046:         SyncTCB();
  1047: 
  1048:         // NOTE: Pending SSL data will NOT be transferred here
  1049: 
  1050:         if(MyTCBStub.txHead != MyTCB.txUnackedTail)
  1051:         {
  1052:                 // Send the TCP segment with all unacked bytes
  1053:                 SendTCP(ACK, SENDTCP_RESET_TIMERS);
  1054:         }
  1055: }
  1056: 
  1057: 
  1058: /*****************************************************************************
  1059:   Function:
  1060:         WORD TCPIsPutReady(TCP_SOCKET hTCP)
  1061: 
  1062:   Summary:
  1063:         Determines how much free space is available in the TCP TX buffer.
  1064: 
  1065:   Description:
  1066:         Call this function to determine how many bytes can be written to the 
  1067:         TCP TX buffer.  If this function returns zero, the application must 
  1068:         return to the main stack loop before continuing in order to transmit
  1069:         more data.
  1070: 
  1071:   Precondition:
  1072:         TCP is initialized.
  1073: 
  1074:   Parameters:
  1075:         hTCP - The socket to check.
  1076: 
  1077:   Returns:
  1078:         The number of bytes available to be written in the TCP TX buffer.
  1079:   ***************************************************************************/
  1080: WORD TCPIsPutReady(TCP_SOCKET hTCP)
  1081: {
  1082:         BYTE i;
  1083: 
  1084:         if(hTCP >= TCP_SOCKET_COUNT)
  1085:     {
  1086:         return 0;
  1087:     }
  1088:     
  1089:         SyncTCBStub(hTCP);
  1090: 
  1091:         i = MyTCBStub.smState;
  1092: 
  1093:         // Unconnected sockets shouldn't be transmitting anything.
  1094:         if(!( (i == (BYTE)TCP_ESTABLISHED) || (i == (BYTE)TCP_CLOSE_WAIT) ))
  1095:                 return 0;
  1096: 
  1097:         // Calculate the free space in this socket's TX FIFO
  1098:         #if defined(STACK_USE_SSL)
  1099:         if(MyTCBStub.sslStubID != SSL_INVALID_ID)
  1100:         {// Use sslTxHead as the head pointer when SSL is active
  1101:                 WORD rem;
  1102:                 
  1103:                 // Find out raw free space
  1104:                 if(MyTCBStub.sslTxHead >= MyTCBStub.txTail)
  1105:                         rem = (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.sslTxHead - MyTCBStub.txTail);
  1106:                 else
  1107:                         rem = MyTCBStub.txTail - MyTCBStub.sslTxHead - 1;
  1108:                         
  1109:                 // Reserve space for a new MAC and header
  1110:                 if(rem > 22u)
  1111:                         return rem - 22;
  1112:                 else
  1113:                         return 0;
  1114:         }
  1115:         #endif
  1116:         
  1117:         if(MyTCBStub.txHead >= MyTCBStub.txTail)
  1118:                 return (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.txHead - MyTCBStub.txTail);
  1119:         else
  1120:                 return MyTCBStub.txTail - MyTCBStub.txHead - 1;
  1121: }
  1122: 
  1123: 
  1124: /*****************************************************************************
  1125:   Function:
  1126:         BOOL TCPPut(TCP_SOCKET hTCP, BYTE byte)
  1127: 
  1128:   Description:
  1129:         Writes a single byte to a TCP socket.
  1130: 
  1131:   Precondition:
  1132:         TCP is initialized.
  1133: 
  1134:   Parameters:
  1135:         hTCP - The socket to which data is to be written.
  1136:         byte - The byte to write.
  1137: 
  1138:   Return Values:
  1139:         TRUE - The byte was written to the transmit buffer.
  1140:         FALSE - The transmit buffer was full, or the socket is not connected.
  1141:   ***************************************************************************/
  1142: BOOL TCPPut(TCP_SOCKET hTCP, BYTE byte)
  1143: {
  1144:         WORD wFreeTXSpace;
  1145: 
  1146:         if(hTCP >= TCP_SOCKET_COUNT)
  1147:     {
  1148:         return 0;
  1149:     }
  1150:     
  1151:         SyncTCBStub(hTCP);
  1152: 
  1153:         wFreeTXSpace = TCPIsPutReady(hTCP);
  1154:         if(wFreeTXSpace == 0u)
  1155:                 return FALSE;
  1156:         else if(wFreeTXSpace == 1u) // About to run out of space, lets transmit so the remote node might send an ACK back faster
  1157:                 TCPFlush(hTCP); 
  1158: 
  1159:         // Send all current bytes if we are crossing half full
  1160:         // This is required to improve performance with the delayed 
  1161:         // acknowledgement algorithm
  1162:         if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1)))
  1163:         {
  1164:                 TCPFlush(hTCP); 
  1165:                 MyTCBStub.Flags.bHalfFullFlush = TRUE;
  1166:         }
  1167: 
  1168:         #if defined(STACK_USE_SSL)
  1169:         if(MyTCBStub.sslStubID != SSL_INVALID_ID)
  1170:         {
  1171:                 TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte));
  1172:                 if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart)
  1173:                         MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
  1174:         }
  1175:         else
  1176:         {
  1177:                 TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte));
  1178:                 if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart)
  1179:                         MyTCBStub.txHead = MyTCBStub.bufferTxStart;
  1180:         }
  1181:         #else
  1182:         TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte));
  1183:         if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart)
  1184:                 MyTCBStub.txHead = MyTCBStub.bufferTxStart;
  1185:         #endif
  1186:         
  1187: 
  1188:         // Send the last byte as a separate packet (likely will make the remote node send back ACK faster)
  1189:         if(wFreeTXSpace == 1u)
  1190:         {
  1191:                 TCPFlush(hTCP);
  1192:         }
  1193:         // If not already enabled, start a timer so this data will 
  1194:         // eventually get sent even if the application doens't call
  1195:         // TCPFlush()
  1196:         else if(!MyTCBStub.Flags.bTimer2Enabled)
  1197:         {
  1198:                 MyTCBStub.Flags.bTimer2Enabled = TRUE;
  1199:                 MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull;
  1200:         }
  1201: 
  1202:         return TRUE;
  1203: }
  1204: 
  1205: /*****************************************************************************
  1206:   Function:
  1207:         WORD TCPPutArray(TCP_SOCKET hTCP, BYTE* data, WORD len)
  1208: 
  1209:   Description:
  1210:         Writes an array from RAM to a TCP socket.
  1211: 
  1212:   Precondition:
  1213:         TCP is initialized.
  1214: 
  1215:   Parameters:
  1216:         hTCP - The socket to which data is to be written.
  1217:         data - Pointer to the array to be written.
  1218:         len  - Number of bytes to be written.
  1219: 
  1220:   Returns:
  1221:         The number of bytes written to the socket.  If less than len, the
  1222:         buffer became full or the socket is not conected.
  1223:   ***************************************************************************/
  1224: WORD TCPPutArray(TCP_SOCKET hTCP, BYTE* data, WORD len)
  1225: {
  1226:         WORD wActualLen;
  1227:         WORD wFreeTXSpace;
  1228:         WORD wRightLen = 0;
  1229: 
  1230:         if(hTCP >= TCP_SOCKET_COUNT)
  1231:     {
  1232:         return 0;
  1233:     }
  1234:     
  1235:         SyncTCBStub(hTCP);
  1236: 
  1237:         wFreeTXSpace = TCPIsPutReady(hTCP);
  1238:         if(wFreeTXSpace == 0u)
  1239:         {
  1240:                 TCPFlush(hTCP);
  1241:                 return 0;
  1242:         }
  1243: 
  1244:         wActualLen = wFreeTXSpace;
  1245:         if(wFreeTXSpace > len)
  1246:                 wActualLen = len;
  1247: 
  1248:         // Send all current bytes if we are crossing half full
  1249:         // This is required to improve performance with the delayed 
  1250:         // acknowledgement algorithm
  1251:         if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1)))
  1252:         {
  1253:                 TCPFlush(hTCP); 
  1254:                 MyTCBStub.Flags.bHalfFullFlush = TRUE;
  1255:         }
  1256:         
  1257:         #if defined(STACK_USE_SSL)
  1258:         if(MyTCBStub.sslStubID != SSL_INVALID_ID)
  1259:         {
  1260:                 // See if we need a two part put
  1261:                 if(MyTCBStub.sslTxHead + wActualLen >= MyTCBStub.bufferRxStart)
  1262:                 {
  1263:                         wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.sslTxHead;
  1264:                         TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen);
  1265:                         data += wRightLen;
  1266:                         wActualLen -= wRightLen;
  1267:                         MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
  1268:                 }
  1269:         
  1270:                 TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen);
  1271:                 MyTCBStub.sslTxHead += wActualLen;
  1272:         }
  1273:         else
  1274:         {
  1275:                 // See if we need a two part put
  1276:                 if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart)
  1277:                 {
  1278:                         wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead;
  1279:                         TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen);
  1280:                         data += wRightLen;
  1281:                         wActualLen -= wRightLen;
  1282:                         MyTCBStub.txHead = MyTCBStub.bufferTxStart;
  1283:                 }
  1284:         
  1285:                 TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen);
  1286:                 MyTCBStub.txHead += wActualLen;
  1287:         }
  1288:         #else
  1289:         // See if we need a two part put
  1290:         if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart)
  1291:         {
  1292:                 wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead;
  1293:                 TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen);
  1294:                 data += wRightLen;
  1295:                 wActualLen -= wRightLen;
  1296:                 MyTCBStub.txHead = MyTCBStub.bufferTxStart;
  1297:         }
  1298: 
  1299:         TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen);
  1300:         MyTCBStub.txHead += wActualLen;
  1301:         #endif
  1302: 
  1303:         // Send these bytes right now if we are out of TX buffer space
  1304:         if(wFreeTXSpace <= len)
  1305:         {
  1306:                 TCPFlush(hTCP);
  1307:         }
  1308:         // If not already enabled, start a timer so this data will 
  1309:         // eventually get sent even if the application doens't call
  1310:         // TCPFlush()
  1311:         else if(!MyTCBStub.Flags.bTimer2Enabled)
  1312:         {
  1313:                 MyTCBStub.Flags.bTimer2Enabled = TRUE;
  1314:                 MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull;
  1315:         }
  1316: 
  1317:         return wActualLen + wRightLen;
  1318: }
  1319: 
  1320: /*****************************************************************************
  1321:   Function:
  1322:         WORD TCPPutROMArray(TCP_SOCKET hTCP, ROM BYTE* data, WORD len)
  1323: 
  1324:   Description:
  1325:         Writes an array from ROM to a TCP socket.
  1326: 
  1327:   Precondition:
  1328:         TCP is initialized.
  1329: 
  1330:   Parameters:
  1331:         hTCP - The socket to which data is to be written.
  1332:         data - Pointer to the array to be written.
  1333:         len  - Number of bytes to be written.
  1334: 
  1335:   Returns:
  1336:         The number of bytes written to the socket.  If less than len, the
  1337:         buffer became full or the socket is not conected.
  1338: 
  1339:   Remarks:
  1340:         This function is aliased to TCPPutArray on non-PIC18 platforms.
  1341:   ***************************************************************************/
  1342: #if defined(__18CXX)
  1343: WORD TCPPutROMArray(TCP_SOCKET hTCP, ROM BYTE* data, WORD len)
  1344: {
  1345:         WORD wActualLen;
  1346:         WORD wFreeTXSpace;
  1347:         WORD wRightLen = 0;
  1348: 
  1349:         if(hTCP >= TCP_SOCKET_COUNT)
  1350:     {
  1351:         return 0;
  1352:     }
  1353:     
  1354:         SyncTCBStub(hTCP);
  1355: 
  1356:         wFreeTXSpace = TCPIsPutReady(hTCP);
  1357:         if(wFreeTXSpace == 0u)
  1358:         {
  1359:                 TCPFlush(hTCP);
  1360:                 return 0;
  1361:         }
  1362: 
  1363:         // Send all current bytes if we are crossing half full
  1364:         // This is required to improve performance with the delayed 
  1365:         // acknowledgement algorithm
  1366:         if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1)))
  1367:         {
  1368:                 TCPFlush(hTCP); 
  1369:                 MyTCBStub.Flags.bHalfFullFlush = TRUE;
  1370:         }
  1371:         
  1372:         wActualLen = wFreeTXSpace;
  1373:         if(wFreeTXSpace > len)
  1374:                 wActualLen = len;
  1375:         
  1376:         #if defined(STACK_USE_SSL)
  1377:         if(MyTCBStub.sslStubID != SSL_INVALID_ID)
  1378:         {
  1379:                 // See if we need a two part put
  1380:                 if(MyTCBStub.sslTxHead + wActualLen >= MyTCBStub.bufferRxStart)
  1381:                 {
  1382:                         wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.sslTxHead;
  1383:                         TCPRAMCopyROM(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, data, wRightLen);
  1384:                         data += wRightLen;
  1385:                         wActualLen -= wRightLen;
  1386:                         MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
  1387:                 }
  1388:         
  1389:                 TCPRAMCopyROM(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, data, wActualLen);
  1390:                 MyTCBStub.sslTxHead += wActualLen;
  1391:         }
  1392:         else
  1393:         {
  1394:                 // See if we need a two part put
  1395:                 if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart)
  1396:                 {
  1397:                         wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead;
  1398:                         TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wRightLen);
  1399:                         data += wRightLen;
  1400:                         wActualLen -= wRightLen;
  1401:                         MyTCBStub.txHead = MyTCBStub.bufferTxStart;
  1402:                 }
  1403:         
  1404:                 TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wActualLen);
  1405:                 MyTCBStub.txHead += wActualLen;
  1406:         }
  1407:         #else
  1408:         // See if we need a two part put
  1409:         if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart)
  1410:         {
  1411:                 wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead;
  1412:                 TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wRightLen);
  1413:                 data += wRightLen;
  1414:                 wActualLen -= wRightLen;
  1415:                 MyTCBStub.txHead = MyTCBStub.bufferTxStart;
  1416:         }
  1417: 
  1418:         TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wActualLen);
  1419:         MyTCBStub.txHead += wActualLen;
  1420:         #endif
  1421: 
  1422:         // Send these bytes right now if we are out of TX buffer space
  1423:         if(wFreeTXSpace <= len)
  1424:         {
  1425:                 TCPFlush(hTCP);
  1426:         }
  1427:         // If not already enabled, start a timer so this data will 
  1428:         // eventually get sent even if the application doens't call
  1429:         // TCPFlush()
  1430:         else if(!MyTCBStub.Flags.bTimer2Enabled)
  1431:         {
  1432:                 MyTCBStub.Flags.bTimer2Enabled = TRUE;
  1433:                 MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull;
  1434:         }
  1435: 
  1436:         return wActualLen + wRightLen;
  1437: }
  1438: #endif
  1439: 
  1440: /*****************************************************************************
  1441:   Function:
  1442:         BYTE* TCPPutString(TCP_SOCKET hTCP, BYTE* data)
  1443: 
  1444:   Description:
  1445:         Writes a null-terminated string from RAM to a TCP socket.  The 
  1446:         null-terminator is not copied to the socket.
  1447: 
  1448:   Precondition:
  1449:         TCP is initialized.
  1450: 
  1451:   Parameters:
  1452:         hTCP - The socket to which data is to be written.
  1453:         data - Pointer to the string to be written.
  1454: 
  1455:   Returns:
  1456:         Pointer to the byte following the last byte written to the socket.  If
  1457:         this pointer does not dereference to a NUL byte, the buffer became full
  1458:         or the socket is not connected.
  1459: 
  1460:   Remarks:
  1461:         The return value of this function differs from that of TCPPutArray.  To
  1462:         write long strings in a single state, initialize the *data pointer to the
  1463:         first byte, then call this function repeatedly (breaking to the main 
  1464:         stack loop after each call) until the return value dereferences to a NUL
  1465:         byte.  Save the return value as the new starting *data pointer otherwise.
  1466:   ***************************************************************************/
  1467: BYTE* TCPPutString(TCP_SOCKET hTCP, BYTE* data)
  1468: {
  1469:         return data + TCPPutArray(hTCP, data, strlen((char*)data));
  1470: }
  1471: 
  1472: /*****************************************************************************
  1473:   Function:
  1474:         BYTE* TCPPutROMString(TCP_SOCKET hTCP, ROM BYTE* data)
  1475: 
  1476:   Description:
  1477:         Writes a null-terminated string from ROM to a TCP socket.  The 
  1478:         null-terminator is not copied to the socket.
  1479: 
  1480:   Precondition:
  1481:         TCP is initialized.
  1482: 
  1483:   Parameters:
  1484:         hTCP - The socket to which data is to be written.
  1485:         data - Pointer to the string to be written.
  1486: 
  1487:   Returns:
  1488:         Pointer to the byte following the last byte written to the socket.  If
  1489:         this pointer does not dereference to a NUL byte, the buffer became full
  1490:         or the socket is not connected.
  1491: 
  1492:   Remarks:
  1493:         The return value of this function differs from that of TCPPutArray.  To
  1494:         write long strings in a single state, initialize the *data pointer to the
  1495:         first byte, then call this function repeatedly (breaking to the main 
  1496:         stack loop after each call) until the return value dereferences to a NUL
  1497:         byte.  Save the return value as the new starting *data pointer otherwise.
  1498:         
  1499:         This function is aliased to TCPPutString on non-PIC18 platforms.
  1500:   ***************************************************************************/
  1501: #if defined(__18CXX)
  1502: ROM BYTE* TCPPutROMString(TCP_SOCKET hTCP, ROM BYTE* data)
  1503: {
  1504:         return data + TCPPutROMArray(hTCP, data, strlenpgm((ROM char*)data));
  1505: }
  1506: #endif
  1507: 
  1508: /*****************************************************************************
  1509:   Function:
  1510:         WORD TCPGetTxFIFOFull(TCP_SOCKET hTCP)
  1511: 
  1512:   Description:
  1513:         Determines how many bytes are pending in the TCP TX FIFO.
  1514: 
  1515:   Precondition:
  1516:         TCP is initialized.
  1517: 
  1518:   Parameters:
  1519:         hTCP - The socket to check.
  1520: 
  1521:   Returns:
  1522:         Number of bytes pending to be flushed in the TCP TX FIFO.
  1523:   ***************************************************************************/
  1524: WORD TCPGetTxFIFOFull(TCP_SOCKET hTCP)
  1525: {
  1526:         WORD wDataLen;
  1527:         WORD wFIFOSize;
  1528: 
  1529:         if(hTCP >= TCP_SOCKET_COUNT)
  1530:     {
  1531:         return 0;
  1532:     }
  1533:     
  1534:         SyncTCBStub(hTCP);
  1535: 
  1536:         // Calculate total usable FIFO size
  1537:         wFIFOSize = MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1;
  1538: 
  1539:         // Find out how many data bytes are free in the TX FIFO
  1540:         wDataLen = TCPIsPutReady(hTCP);
  1541: 
  1542:         return wFIFOSize - wDataLen;
  1543: }
  1544: 
  1545: 
  1546: 
  1547: /****************************************************************************
  1548:   Section:
  1549:         Receive Functions
  1550:   ***************************************************************************/
  1551: 
  1552: /*****************************************************************************
  1553:   Function:
  1554:         void TCPDiscard(TCP_SOCKET hTCP)
  1555: 
  1556:   Description:
  1557:         Discards any pending data in the TCP RX FIFO.
  1558: 
  1559:   Precondition:
  1560:         TCP is initialized.
  1561: 
  1562:   Parameters:
  1563:         hTCP - The socket whose RX FIFO is to be cleared.
  1564: 
  1565:   Returns:
  1566:         None
  1567:   ***************************************************************************/
  1568: void TCPDiscard(TCP_SOCKET hTCP)
  1569: {
  1570:         if(TCPIsGetReady(hTCP))
  1571:         {
  1572:                 SyncTCBStub(hTCP);
  1573:         
  1574:                 // Delete all data in the RX buffer
  1575:                 MyTCBStub.rxTail = MyTCBStub.rxHead;
  1576:         
  1577:                 // Send a Window update message to the remote node
  1578:                 SendTCP(ACK, SENDTCP_RESET_TIMERS);
  1579:         }
  1580: }
  1581: 
  1582: 
  1583: /*****************************************************************************
  1584:   Function:
  1585:         void WORD TCPIsGetReady(TCP_SOCKET hTCP)
  1586: 
  1587:   Summary:
  1588:         Determines how many bytes can be read from the TCP RX buffer.
  1589: 
  1590:   Description:
  1591:         Call this function to determine how many bytes can be read from the 
  1592:         TCP RX buffer.  If this function returns zero, the application must 
  1593:         return to the main stack loop before continuing in order to wait for
  1594:         more data to arrive.
  1595: 
  1596:   Precondition:
  1597:         TCP is initialized.
  1598: 
  1599:   Parameters:
  1600:         hTCP - The socket to check.
  1601: 
  1602:   Returns:
  1603:         The number of bytes available to be read from the TCP RX buffer.
  1604:   ***************************************************************************/
  1605: WORD TCPIsGetReady(TCP_SOCKET hTCP)
  1606: {
  1607:         if(hTCP >= TCP_SOCKET_COUNT)
  1608:     {
  1609:         return 0;
  1610:     }
  1611:     
  1612:         SyncTCBStub(hTCP);
  1613:                 
  1614:         if(MyTCBStub.rxHead >= MyTCBStub.rxTail)
  1615:                 return MyTCBStub.rxHead - MyTCBStub.rxTail;
  1616:         else
  1617:                 return (MyTCBStub.bufferEnd - MyTCBStub.rxTail + 1) + (MyTCBStub.rxHead - MyTCBStub.bufferRxStart);
  1618: }
  1619: 
  1620: 
  1621: /*****************************************************************************
  1622:   Function:
  1623:         BOOL TCPGet(TCP_SOCKET hTCP, BYTE* byte)
  1624: 
  1625:   Description:
  1626:         Retrieves a single byte to a TCP socket.
  1627: 
  1628:   Precondition:
  1629:         TCP is initialized.
  1630: 
  1631:   Parameters:
  1632:         hTCP - The socket from which to read.
  1633:         byte - Pointer to location in which the read byte should be stored.
  1634: 
  1635:   Return Values:
  1636:         TRUE - A byte was read from the buffer.
  1637:         FALSE - The buffer was empty, or the socket is not connected.
  1638:   ***************************************************************************/
  1639: BOOL TCPGet(TCP_SOCKET hTCP, BYTE* byte)
  1640: {
  1641:         WORD wGetReadyCount;
  1642: 
  1643:         // See if there is any data which can be read
  1644:         wGetReadyCount = TCPIsGetReady(hTCP);
  1645:         if(wGetReadyCount == 0u)
  1646:                 return FALSE;
  1647: 
  1648:         SyncTCBStub(hTCP);
  1649:         
  1650:         if(byte)
  1651:                 TCPRAMCopy((PTR_BASE)byte, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, 1);
  1652:         if(++MyTCBStub.rxTail > MyTCBStub.bufferEnd)
  1653:                 MyTCBStub.rxTail = MyTCBStub.bufferRxStart;
  1654: 
  1655:         // Send a window update if we've run out of data
  1656:         if(wGetReadyCount == 1u)
  1657:         {
  1658:                 MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1;
  1659:         }
  1660:         // If not already enabled, start a timer so a window 
  1661:         // update will get sent to the remote node at some point
  1662:         else if(!MyTCBStub.Flags.bTimer2Enabled)
  1663:         {
  1664:                 MyTCBStub.Flags.bTimer2Enabled = TRUE;
  1665:                 MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_WINDOW_UPDATE_TIMEOUT_VAL/256ull;
  1666:         }
  1667: 
  1668: 
  1669:         return TRUE;
  1670: }
  1671: 
  1672: 
  1673: /*****************************************************************************
  1674:   Function:
  1675:         WORD TCPGetArray(TCP_SOCKET hTCP, BYTE* buffer, WORD len)
  1676: 
  1677:   Description:
  1678:         Reads an array of data bytes from a TCP socket's receive FIFO.  The data 
  1679:         is removed from the FIFO in the process.
  1680: 
  1681:   Precondition:
  1682:         TCP is initialized.
  1683: 
  1684:   Parameters:
  1685:         hTCP - The socket from which data is to be read.
  1686:         buffer - Pointer to the array to store data that was read.
  1687:         len  - Number of bytes to be read.
  1688: 
  1689:   Returns:
  1690:         The number of bytes read from the socket.  If less than len, the
  1691:         RX FIFO buffer became empty or the socket is not conected.
  1692:   ***************************************************************************/
  1693: WORD TCPGetArray(TCP_SOCKET hTCP, BYTE* buffer, WORD len)
  1694: {
  1695:         WORD wGetReadyCount;
  1696:         WORD RightLen = 0;
  1697: 
  1698:         // See if there is any data which can be read
  1699:         wGetReadyCount = TCPIsGetReady(hTCP);
  1700:         if(wGetReadyCount == 0u)
  1701:                 return 0x0000u;
  1702: 
  1703:         SyncTCBStub(hTCP);
  1704: 
  1705:         // Make sure we don't try to read more data than is available
  1706:         if(len > wGetReadyCount)
  1707:                 len = wGetReadyCount;
  1708: 
  1709:         // See if we need a two part get
  1710:         if(MyTCBStub.rxTail + len > MyTCBStub.bufferEnd)
  1711:         {
  1712:                 RightLen = MyTCBStub.bufferEnd - MyTCBStub.rxTail + 1;
  1713:                 if(buffer)
  1714:                 {
  1715:                         TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, RightLen);
  1716:                         buffer += RightLen;
  1717:                 }
  1718:                 len -= RightLen;
  1719:                 MyTCBStub.rxTail = MyTCBStub.bufferRxStart;
  1720:         }
  1721: 
  1722:         if(buffer)
  1723:                 TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, len);
  1724:         MyTCBStub.rxTail += len;
  1725:         len += RightLen;
  1726: 
  1727:         // Send a window update if we've run low on data
  1728:         if(wGetReadyCount - len <= len)
  1729:         {
  1730:                 MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1;
  1731:         }
  1732:         else if(!MyTCBStub.Flags.bTimer2Enabled)
  1733:         // If not already enabled, start a timer so a window 
  1734:         // update will get sent to the remote node at some point
  1735:         {
  1736:                 MyTCBStub.Flags.bTimer2Enabled = TRUE;
  1737:                 MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_WINDOW_UPDATE_TIMEOUT_VAL/256ull;
  1738:         }
  1739: 
  1740:         return len;
  1741: }
  1742: 
  1743: 
  1744: /*****************************************************************************
  1745:   Function:
  1746:         WORD TCPGetRxFIFOFree(TCP_SOCKET hTCP)
  1747: 
  1748:   Description:
  1749:         Determines how many bytes are free in the RX FIFO.
  1750: 
  1751:   Precondition:
  1752:         TCP is initialized.
  1753: 
  1754:   Parameters:
  1755:         hTCP - The socket to check.
  1756: 
  1757:   Returns:
  1758:         The number of bytes free in the TCP RX FIFO.  If zero, no additional 
  1759:         data can be received until the application removes some data using one
  1760:         of the TCPGet family functions.
  1761:   ***************************************************************************/
  1762: WORD TCPGetRxFIFOFree(TCP_SOCKET hTCP)
  1763: {
  1764:         WORD wDataLen;
  1765:         WORD wFIFOSize;
  1766:         
  1767:         if(hTCP >= TCP_SOCKET_COUNT)
  1768:     {
  1769:         return 0;
  1770:     }
  1771:     
  1772:         SyncTCBStub(hTCP);
  1773:         
  1774:         // Calculate total usable FIFO size
  1775:         wFIFOSize = MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart;
  1776: 
  1777:         #if defined(STACK_USE_SSL)
  1778:         {
  1779:                 PTR_BASE SSLtemp = MyTCBStub.rxHead;
  1780: 
  1781:                 // Move SSL pointer to determine full buffer size
  1782:                 if(MyTCBStub.sslStubID != SSL_INVALID_ID)
  1783:                         MyTCBStub.rxHead = MyTCBStub.sslRxHead;
  1784: 
  1785:                 // Find out how many data bytes are actually in the RX FIFO
  1786:                 wDataLen = TCPIsGetReady(hTCP);
  1787:                 
  1788:                 // Move SSL pointer back to proper location (if we changed it)
  1789:                 MyTCBStub.rxHead = SSLtemp;
  1790:         }
  1791:         #else
  1792:         {
  1793:                 // Find out how many data bytes are actually in the RX FIFO
  1794:                 wDataLen = TCPIsGetReady(hTCP);
  1795:         }
  1796:         #endif
  1797:         
  1798:         // Perform the calculation      
  1799:         return wFIFOSize - wDataLen;
  1800: }
  1801: 
  1802: /*****************************************************************************
  1803:   Function:
  1804:         WORD TCPPeekArray(TCP_SOCKET hTCP, BYTE *vBuffer, WORD wLen, WORD wStart)
  1805: 
  1806:   Summary:
  1807:         Reads a specified number of data bytes from the TCP RX FIFO without 
  1808:         removing them from the buffer.
  1809: 
  1810:   Description:
  1811:         Reads a specified number of data bytes from the TCP RX FIFO without 
  1812:         removing them from the buffer.  No TCP control actions are taken as a 
  1813:         result of this function (ex: no window update is sent to the remote node).
  1814:         
  1815:   Precondition:
  1816:         TCP is initialized.
  1817: 
  1818:   Parameters:
  1819:         hTCP - The socket to peak from (read without removing from stream).
  1820:         vBuffer - Destination to write the peeked data bytes.
  1821:         wLen - Length of bytes to peak from the RX FIFO and copy to vBuffer.
  1822:         wStart - Zero-indexed starting position within the FIFO to start peeking 
  1823:                 from.
  1824: 
  1825:   Return Values:
  1826:         Number of bytes actually peeked from the stream and copied to vBuffer.  
  1827:         This value can be less than wLen if wStart + wLen is greater than the 
  1828:         deepest possible character in the RX FIFO.
  1829: 
  1830:   Remarks:
  1831:         None
  1832:   ***************************************************************************/
  1833: WORD TCPPeekArray(TCP_SOCKET hTCP, BYTE *vBuffer, WORD wLen, WORD wStart)
  1834: {
  1835:         PTR_BASE ptrRead;
  1836:         WORD w;
  1837:         WORD wBytesUntilWrap;
  1838: 
  1839:         if(hTCP >= TCP_SOCKET_COUNT || wLen == 0)
  1840:     {
  1841:         return 0;
  1842:     }
  1843:     
  1844:         SyncTCBStub(hTCP);
  1845: 
  1846:         // Find out how many bytes are in the RX FIFO and decrease read length 
  1847:         // if the start offset + read length is beyond the end of the FIFO
  1848:         w = TCPIsGetReady(hTCP);
  1849:         if(wStart + wLen > w)
  1850:                 wLen = w - wStart;
  1851: 
  1852:         // Find the read start location
  1853:         ptrRead = MyTCBStub.rxTail + wStart;
  1854:         if(ptrRead > MyTCBStub.bufferEnd)
  1855:                 ptrRead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;
  1856: 
  1857:         // Calculate how many bytes can be read in a single go
  1858:         wBytesUntilWrap = MyTCBStub.bufferEnd - ptrRead + 1;
  1859:         if(wLen <= wBytesUntilWrap)
  1860:         {
  1861:                 // Read all at once
  1862:                 TCPRAMCopy((PTR_BASE)vBuffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, wLen);
  1863:         }
  1864:         else
  1865:         {
  1866:                 // Read all bytes up to the wrap position and then read remaining bytes 
  1867:                 // at the start of the buffer
  1868:                 TCPRAMCopy((PTR_BASE)vBuffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, wBytesUntilWrap);
  1869:                 TCPRAMCopy((PTR_BASE)vBuffer+wBytesUntilWrap, TCP_PIC_RAM, MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, wLen - wBytesUntilWrap);
  1870:         }
  1871:         
  1872:         return wLen;
  1873: }
  1874: 
  1875: /*****************************************************************************
  1876:   Function:
  1877:         BYTE TCPPeek(TCP_SOCKET hTCP, WORD wStart)
  1878: 
  1879:   Summary:
  1880:         Peaks at one byte in the TCP RX FIFO without removing it from the buffer.
  1881: 
  1882:   Description:
  1883:         Peaks at one byte in the TCP RX FIFO without removing it from the buffer.
  1884:         
  1885:   Precondition:
  1886:         TCP is initialized.
  1887: 
  1888:   Parameters:
  1889:         hTCP - The socket to peak from (read without removing from stream).
  1890:         wStart - Zero-indexed starting position within the FIFO to peek from.
  1891: 
  1892:   Return Values:
  1893:         Byte peeked from the RX FIFO.  If there is no data in the buffer or an 
  1894:         illegal wStart starting offset is given, then an indeterminate value is 
  1895:         returned.  The caller must ensure that valid parameters are passed to avoid 
  1896:         (i.e ensure that TCPIsGetReady() returns a number that is less than wStart 
  1897:         before calling TCPPeek()).
  1898: 
  1899:   Remarks:
  1900:         Use the TCPPeekArray() function to read more than one byte.  It will 
  1901:         perform better than calling TCPPeek() in a loop.
  1902:   ***************************************************************************/
  1903: BYTE TCPPeek(TCP_SOCKET hTCP, WORD wStart)
  1904: {
  1905:         BYTE i;
  1906:         
  1907:         TCPPeekArray(hTCP, &i, 1, wStart);
  1908:         return i;
  1909: }
  1910: 
  1911: 
  1912: /****************************************************************************
  1913:   Section:
  1914:         Search Functions
  1915:   ***************************************************************************/
  1916: 
  1917: /*****************************************************************************
  1918:   Function:
  1919:         WORD TCPFindArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen, 
  1920:                                                 WORD wStart, WORD wSearchLen, BOOL bTextCompare)
  1921: 
  1922:   Summary:
  1923:         Searches for a string in the TCP RX buffer.
  1924: 
  1925:   Description:
  1926:         This function finds the first occurrance of an array of bytes in the
  1927:         TCP RX buffer.  It can be used by an application to abstract searches 
  1928:         out of their own application code.  For increased efficiency, the 
  1929:         function is capable of limiting the scope of search to a specific
  1930:         range of bytes.  It can also perform a case-insensitive search if
  1931:         required.
  1932:         
  1933:         For example, if the buffer contains "I love PIC MCUs!" and the search
  1934:         array is "love" with a length of 4, a value of 2 will be returned.
  1935: 
  1936:   Precondition:
  1937:         TCP is initialized.
  1938: 
  1939:   Parameters:
  1940:         hTCP - The socket to search within.
  1941:         cFindArray - The array of bytes to find in the buffer.
  1942:         wLen - Length of cFindArray.
  1943:         wStart - Zero-indexed starting position within the buffer.
  1944:         wSearchLen - Length from wStart to search in the buffer.
  1945:         bTextCompare - TRUE for case-insensitive text search, FALSE for binary search
  1946: 
  1947:   Return Values:
  1948:         0xFFFF - Search array not found
  1949:         Otherwise - Zero-indexed position of the first occurrance
  1950: 
  1951:   Remarks:
  1952:         Since this function usually must transfer data from external storage
  1953:         to internal RAM for comparison, its performance degrades significantly
  1954:         when the buffer is full and the array is not found.  For better 
  1955:         performance, try to search for characters that are expected to exist or
  1956:         limit the scope of the search as much as possible.  The HTTP2 module, 
  1957:         for example, uses this function to parse headers.  However, it searches 
  1958:         for newlines, then the separating colon, then reads the header name to 
  1959:         RAM for final comparison.  This has proven to be significantly faster  
  1960:         than searching for full header name strings outright.
  1961:   ***************************************************************************/
  1962: WORD TCPFindArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare)
  1963: {
  1964:         PTR_BASE ptrRead;
  1965:         WORD wDataLen;
  1966:         WORD wBytesUntilWrap;
  1967:         PTR_BASE ptrLocation;
  1968:         WORD wLenStart;
  1969:         BYTE *cFindArrayStart;
  1970:         BYTE i, j, k;
  1971:         BOOL isFinding;
  1972:         BYTE buffer[32];
  1973: 
  1974:         if(hTCP >= TCP_SOCKET_COUNT || wLen == 0)
  1975:     {
  1976:         return 0;
  1977:     }
  1978:     
  1979:         SyncTCBStub(hTCP);
  1980: 
  1981:         // Find out how many bytes are in the RX FIFO and return 
  1982:         // immediately if we won't possibly find a match
  1983:         wDataLen = TCPIsGetReady(hTCP) - wStart;
  1984:         if(wDataLen < wLen)
  1985:                 return 0xFFFFu;
  1986:         if(wSearchLen && (wDataLen > wSearchLen))
  1987:                 wDataLen = wSearchLen;
  1988: 
  1989:         ptrLocation = MyTCBStub.rxTail + wStart;
  1990:         if(ptrLocation > MyTCBStub.bufferEnd)
  1991:                 ptrLocation -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;
  1992:         ptrRead = ptrLocation;
  1993:         wBytesUntilWrap = MyTCBStub.bufferEnd - ptrLocation + 1;
  1994:         ptrLocation = wStart;
  1995:         wLenStart = wLen;
  1996:         cFindArrayStart = cFindArray;
  1997:         j = *cFindArray++;
  1998:         isFinding = FALSE;
  1999:         if(bTextCompare)
  2000:         {
  2001:                 if(j >= 'a' && j <= 'z')
  2002:                         j += 'A'-'a';
  2003:         }
  2004: 
  2005:         // Search for the array
  2006:         while(1)
  2007:         {
  2008:                 // Figure out how big of a chunk to read
  2009:                 k = sizeof(buffer);
  2010:                 if(k > wBytesUntilWrap)
  2011:                         k = wBytesUntilWrap;
  2012:                 if((WORD)k > wDataLen)
  2013:                         k = wDataLen;
  2014: 
  2015:                 // Read a chunk of data into the buffer
  2016:                 TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, (WORD)k);
  2017:                 ptrRead += k;
  2018:                 wBytesUntilWrap -= k;
  2019: 
  2020:                 if(wBytesUntilWrap == 0u)
  2021:                 {
  2022:                         ptrRead = MyTCBStub.bufferRxStart;
  2023:                         wBytesUntilWrap = 0xFFFFu;
  2024:                 }
  2025: 
  2026:                 // Convert everything to uppercase
  2027:                 if(bTextCompare)
  2028:                 {
  2029:                         for(i = 0; i < k; i++)
  2030:                         {
  2031:                                 if(buffer[i] >= 'a' && buffer[i] <= 'z')
  2032:                                         buffer[i] += 'A'-'a';
  2033: 
  2034:                                 if(j == buffer[i])
  2035:                                 {
  2036:                                         if(--wLen == 0u)
  2037:                                                 return ptrLocation-wLenStart + i + 1;
  2038:                                         j = *cFindArray++;
  2039:                                         isFinding = TRUE;
  2040:                                         if(j >= 'a' && j <= 'z')
  2041:                                                 j += 'A'-'a';
  2042:                                 }
  2043:                                 else
  2044:                                 {
  2045:                                         wLen = wLenStart;
  2046:                                         if(isFinding)
  2047:                                         {
  2048:                                                 cFindArray = cFindArrayStart;
  2049:                                                 j = *cFindArray++;
  2050:                                                 if(j >= 'a' && j <= 'z')
  2051:                                                         j += 'A'-'a';
  2052:                                                 isFinding = FALSE;
  2053:                                         }
  2054:                                 }
  2055:                         }
  2056:                 }
  2057:                 else    // Compare as is
  2058:                 {
  2059:                         for(i = 0; i < k; i++)
  2060:                         {
  2061:                                 if(j == buffer[i])
  2062:                                 {
  2063:                                         if(--wLen == 0u)
  2064:                                                 return ptrLocation-wLenStart + i + 1;
  2065:                                         j = *cFindArray++;
  2066:                                         isFinding = TRUE;
  2067:                                 }
  2068:                                 else
  2069:                                 {
  2070:                                         wLen = wLenStart;
  2071:                                         if(isFinding)
  2072:                                         {
  2073:                                                 cFindArray = cFindArrayStart;
  2074:                                                 j = *cFindArray++;
  2075:                                                 isFinding = FALSE;
  2076:                                         }
  2077:                                 }
  2078:                         }
  2079:                 }
  2080: 
  2081:                 // Check to see if it is impossible to find a match
  2082:                 wDataLen -= k;
  2083:                 if(wDataLen < wLen)
  2084:                         return 0xFFFFu;
  2085: 
  2086:                 ptrLocation += k;
  2087:         }
  2088: }
  2089: 
  2090: /*****************************************************************************
  2091:   Function:
  2092:         WORD TCPFindROMArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen, 
  2093:                                                 WORD wStart, WORD wSearchLen, BOOL bTextCompare)
  2094: 
  2095:   Summary:
  2096:         Searches for a ROM string in the TCP RX buffer.
  2097: 
  2098:   Description:
  2099:         This function finds the first occurrance of an array of bytes in the
  2100:         TCP RX buffer.  It can be used by an application to abstract searches 
  2101:         out of their own application code.  For increased efficiency, the 
  2102:         function is capable of limiting the scope of search to a specific
  2103:         range of bytes.  It can also perform a case-insensitive search if
  2104:         required.
  2105:         
  2106:         For example, if the buffer contains "I love PIC MCUs!" and the search
  2107:         array is "love" with a length of 4, a value of 2 will be returned.
  2108: 
  2109:   Precondition:
  2110:         TCP is initialized.
  2111: 
  2112:   Parameters:
  2113:         hTCP - The socket to search within.
  2114:         cFindArray - The array of bytes to find in the buffer.
  2115:         wLen - Length of cFindArray.
  2116:         wStart - Zero-indexed starting position within the buffer.
  2117:         wSearchLen - Length from wStart to search in the buffer.
  2118:         bTextCompare - TRUE for case-insensitive text search, FALSE for binary search
  2119: 
  2120:   Return Values:
  2121:         0xFFFF - Search array not found
  2122:         Otherwise - Zero-indexed position of the first occurrance
  2123: 
  2124:   Remarks:
  2125:         Since this function usually must transfer data from external storage
  2126:         to internal RAM for comparison, its performance degrades significantly
  2127:         when the buffer is full and the array is not found.  For better 
  2128:         performance, try to search for characters that are expected to exist or
  2129:         limit the scope of the search as much as possible.  The HTTP2 module, 
  2130:         for example, uses this function to parse headers.  However, it searches 
  2131:         for newlines, then the separating colon, then reads the header name to 
  2132:         RAM for final comparison.  This has proven to be significantly faster  
  2133:         than searching for full header name strings outright.
  2134:         
  2135:         This function is aliased to TCPFindArrayEx on non-PIC18 platforms.
  2136:   ***************************************************************************/
  2137: #if defined(__18CXX)
  2138: WORD TCPFindROMArrayEx(TCP_SOCKET hTCP, ROM BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare)
  2139: {
  2140:         PTR_BASE ptrRead;
  2141:         WORD wDataLen;
  2142:         WORD wBytesUntilWrap;
  2143:         PTR_BASE ptrLocation;
  2144:         WORD wLenStart;
  2145:         ROM BYTE *cFindArrayStart;
  2146:         BYTE i, j, k;
  2147:         BOOL isFinding;
  2148:         BYTE buffer[32];
  2149: 
  2150:         if(hTCP >= TCP_SOCKET_COUNT || wLen == 0)
  2151:     {
  2152:         return 0;
  2153:     }
  2154:     
  2155:         SyncTCBStub(hTCP);
  2156: 
  2157:         // Find out how many bytes are in the RX FIFO and return 
  2158:         // immediately if we won't possibly find a match
  2159:         wDataLen = TCPIsGetReady(hTCP) - wStart;
  2160:         if(wDataLen < wLen)
  2161:                 return 0xFFFFu;
  2162:         if(wSearchLen && (wDataLen > wSearchLen))
  2163:                 wDataLen = wSearchLen;
  2164: 
  2165:         ptrLocation = MyTCBStub.rxTail + wStart;
  2166:         if(ptrLocation > MyTCBStub.bufferEnd)
  2167:                 ptrLocation -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;
  2168:         ptrRead = ptrLocation;
  2169:         wBytesUntilWrap = MyTCBStub.bufferEnd - ptrLocation + 1;
  2170:         ptrLocation = wStart;
  2171:         wLenStart = wLen;
  2172:         cFindArrayStart = cFindArray;
  2173:         j = *cFindArray++;
  2174:         isFinding = FALSE;
  2175:         if(bTextCompare)
  2176:         {
  2177:                 if(j >= 'a' && j <= 'z')
  2178:                         j += 'A'-'a';
  2179:         }
  2180: 
  2181:         // Search for the array
  2182:         while(1)
  2183:         {
  2184:                 // Figure out how big of a chunk to read
  2185:                 k = sizeof(buffer);
  2186:                 if(k > wBytesUntilWrap)
  2187:                         k = wBytesUntilWrap;
  2188:                 if((WORD)k > wDataLen)
  2189:                         k = wDataLen;
  2190: 
  2191:                 // Read a chunk of data into the buffer
  2192:                 TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, (WORD)k);
  2193:                 ptrRead += k;
  2194:                 wBytesUntilWrap -= k;
  2195: 
  2196:                 if(wBytesUntilWrap == 0u)
  2197:                 {
  2198:                         ptrRead = MyTCBStub.bufferRxStart;
  2199:                         wBytesUntilWrap = 0xFFFFu;
  2200:                 }
  2201: 
  2202:                 // Convert everything to uppercase
  2203:                 if(bTextCompare)
  2204:                 {
  2205:                         for(i = 0; i < k; i++)
  2206:                         {
  2207:                                 if(buffer[i] >= 'a' && buffer[i] <= 'z')
  2208:                                         buffer[i] += 'A'-'a';
  2209: 
  2210:                                 if(j == buffer[i])
  2211:                                 {
  2212:                                         if(--wLen == 0u)
  2213:                                                 return ptrLocation-wLenStart + i + 1;
  2214:                                         j = *cFindArray++;
  2215:                                         isFinding = TRUE;
  2216:                                         if(j >= 'a' && j <= 'z')
  2217:                                                 j += 'A'-'a';
  2218:                                 }
  2219:                                 else
  2220:                                 {
  2221:                                         wLen = wLenStart;
  2222:                                         if(isFinding)
  2223:                                         {
  2224:                                                 cFindArray = cFindArrayStart;
  2225:                                                 j = *cFindArray++;
  2226:                                                 if(j >= 'a' && j <= 'z')
  2227:                                                         j += 'A'-'a';
  2228:                                                 isFinding = FALSE;
  2229:                                         }
  2230:                                 }
  2231:                         }
  2232:                 }
  2233:                 else    // Compare as is
  2234:                 {
  2235:                         for(i = 0; i < k; i++)
  2236:                         {
  2237:                                 if(j == buffer[i])
  2238:                                 {
  2239:                                         if(--wLen == 0u)
  2240:                                                 return ptrLocation-wLenStart + i + 1;
  2241:                                         j = *cFindArray++;
  2242:                                         isFinding = TRUE;
  2243:                                 }
  2244:                                 else
  2245:                                 {
  2246:                                         wLen = wLenStart;
  2247:                                         if(isFinding)
  2248:                                         {
  2249:                                                 cFindArray = cFindArrayStart;
  2250:                                                 j = *cFindArray++;
  2251:                                                 isFinding = FALSE;
  2252:                                         }
  2253:                                 }
  2254:                         }
  2255:                 }
  2256: 
  2257:                 // Check to see if it is impossible to find a match
  2258:                 wDataLen -= k;
  2259:                 if(wDataLen < wLen)
  2260:                         return 0xFFFFu;
  2261: 
  2262:                 ptrLocation += k;
  2263:         }
  2264: }
  2265: #endif
  2266: 
  2267: 
  2268: /*****************************************************************************
  2269:   Function:
  2270:         WORD TCPFindEx(TCP_SOCKET hTCP, BYTE cFind,
  2271:                                                 WORD wStart, WORD wSearchLen, BOOL bTextCompare)
  2272: 
  2273:   Summary:
  2274:         Searches for a byte in the TCP RX buffer.
  2275: 
  2276:   Description:
  2277:         This function finds the first occurrance of a byte in the TCP RX
  2278:         buffer.  It can be used by an application to abstract searches 
  2279:         out of their own application code.  For increased efficiency, the 
  2280:         function is capable of limiting the scope of search to a specific
  2281:         range of bytes.  It can also perform a case-insensitive search if
  2282:         required.
  2283:         
  2284:         For example, if the buffer contains "I love PIC MCUs!" and the cFind
  2285:         byte is ' ', a value of 1 will be returned.
  2286: 
  2287:   Precondition:
  2288:         TCP is initialized.
  2289: 
  2290:   Parameters:
  2291:         hTCP - The socket to search within.
  2292:         cFind - The byte to find in the buffer.
  2293:         wStart - Zero-indexed starting position within the buffer.
  2294:         wSearchLen - Length from wStart to search in the buffer.
  2295:         bTextCompare - TRUE for case-insensitive text search, FALSE for binary search
  2296: 
  2297:   Return Values:
  2298:         0xFFFF - Search array not found
  2299:         Otherwise - Zero-indexed position of the first occurrance
  2300: 
  2301:   Remarks:
  2302:         Since this function usually must transfer data from external storage
  2303:         to internal RAM for comparison, its performance degrades significantly
  2304:         when the buffer is full and the array is not found.  For better 
  2305:         performance, try to search for characters that are expected to exist or
  2306:         limit the scope of the search as much as possible.  The HTTP2 module, 
  2307:         for example, uses this function to parse headers.  However, it searches 
  2308:         for newlines, then the separating colon, then reads the header name to 
  2309:         RAM for final comparison.  This has proven to be significantly faster  
  2310:         than searching for full header name strings outright.
  2311:   ***************************************************************************/
  2312: WORD TCPFindEx(TCP_SOCKET hTCP, BYTE cFind, WORD wStart, WORD wSearchLen, BOOL bTextCompare)
  2313: {
  2314:         return TCPFindArrayEx(hTCP, &cFind, sizeof(cFind), wStart, wSearchLen, bTextCompare);
  2315: }
  2316: 
  2317: 
  2318: 
  2319: /****************************************************************************
  2320:   Section:
  2321:         Data Processing Functions
  2322:   ***************************************************************************/
  2323: 
  2324: /*****************************************************************************
  2325:   Function:
  2326:         void TCPTick(void)
  2327: 
  2328:   Summary:
  2329:         Performs periodic TCP tasks.
  2330: 
  2331:   Description:
  2332:         This function performs any required periodic TCP tasks.  Each 
  2333:         socket's state machine is checked, and any elapsed timeout periods
  2334:         are handled.
  2335: 
  2336:   Precondition:
  2337:         TCP is initialized.
  2338: 
  2339:   Parameters:
  2340:         None
  2341: 
  2342:   Returns:
  2343:         None
  2344:   ***************************************************************************/
  2345: void TCPTick(void)
  2346: {
  2347:         TCP_SOCKET hTCP;
  2348:         BOOL bRetransmit;
  2349:         BOOL bCloseSocket;
  2350:         BYTE vFlags;
  2351:         WORD w;
  2352: 
  2353:         // Periodically all "not closed" sockets must perform timed operations
  2354:         for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++)
  2355:         {
  2356:                 SyncTCBStub(hTCP);
  2357:                 
  2358:                 // Handle any SSL Processing and Message Transmission
  2359:                 #if defined(STACK_USE_SSL)
  2360:                 if(MyTCBStub.sslStubID != SSL_INVALID_ID)
  2361:                 {
  2362:                         // Handle any periodic tasks, such as RSA operations
  2363:                         SSLPeriodic(hTCP, MyTCBStub.sslStubID);
  2364:                         
  2365:                         // If unsent data is waiting, transmit it as an application record
  2366:                         if(MyTCBStub.sslTxHead != MyTCBStub.txHead && TCPSSLGetPendingTxSize(hTCP) != 0u)
  2367:                                 SSLTxRecord(hTCP, MyTCBStub.sslStubID, SSL_APPLICATION);
  2368:                         
  2369:                         // If an SSL message is requested, send it now
  2370:                         if(MyTCBStub.sslReqMessage != SSL_NO_MESSAGE)
  2371:                                 SSLTxMessage(hTCP, MyTCBStub.sslStubID, MyTCBStub.sslReqMessage);
  2372:                 }
  2373:                 #endif
  2374:                 
  2375:                 vFlags = 0x00;
  2376:                 bRetransmit = FALSE;
  2377:                 bCloseSocket = FALSE;
  2378: 
  2379:                 // Transmit ASAP data if the medium is available
  2380:                 if(MyTCBStub.Flags.bTXASAP || MyTCBStub.Flags.bTXASAPWithoutTimerReset)
  2381:                 {
  2382:                         if(MACIsTxReady())
  2383:                         {
  2384:                                 vFlags = ACK;
  2385:                                 bRetransmit = MyTCBStub.Flags.bTXASAPWithoutTimerReset;
  2386:                         }
  2387:                 }
  2388: 
  2389:                 // Perform any needed window updates and data transmissions
  2390:                 if(MyTCBStub.Flags.bTimer2Enabled)
  2391:                 {
  2392:                         // See if the timeout has occured, and we need to send a new window update and pending data
  2393:                         if((SHORT)(MyTCBStub.eventTime2 - (WORD)TickGetDiv256()) <= (SHORT)0)
  2394:                                 vFlags = ACK;
  2395:                 }
  2396: 
  2397:                 // Process Delayed ACKnowledgement timer
  2398:                 if(MyTCBStub.Flags.bDelayedACKTimerEnabled)
  2399:                 {
  2400:                         // See if the timeout has occured and delayed ACK needs to be sent
  2401:                         if((SHORT)(MyTCBStub.OverlappedTimers.delayedACKTime - (WORD)TickGetDiv256()) <= (SHORT)0)
  2402:                                 vFlags = ACK;
  2403:                 }
  2404:                 
  2405:                 // Process TCP_CLOSE_WAIT timer
  2406:                 if(MyTCBStub.smState == TCP_CLOSE_WAIT)
  2407:                 {
  2408:                         // Automatically close the socket on our end if the application 
  2409:                         // fails to call TCPDisconnect() is a reasonable amount of time.
  2410:                         if((SHORT)(MyTCBStub.OverlappedTimers.closeWaitTime - (WORD)TickGetDiv256()) <= (SHORT)0)
  2411:                         {
  2412:                                 vFlags = FIN | ACK;
  2413:                                 MyTCBStub.smState = TCP_LAST_ACK;
  2414:                         }
  2415:                 }
  2416: 
  2417:                 // Process listening server sockets that might have a SYN waiting in the SYNQueue[]
  2418:                 #if TCP_SYN_QUEUE_MAX_ENTRIES
  2419:                         if(MyTCBStub.smState == TCP_LISTEN)
  2420:                         {
  2421:                                 for(w = 0; w < TCP_SYN_QUEUE_MAX_ENTRIES; w++)
  2422:                                 {
  2423:                                         // Abort search if there are no more valid records
  2424:                                         if(SYNQueue[w].wDestPort == 0u)
  2425:                                                 break;
  2426:                                         
  2427:                                         // Stop searching if this SYN queue entry can be used by this socket
  2428:                                         #if defined(STACK_USE_SSL_SERVER)
  2429:                                         if(SYNQueue[w].wDestPort == MyTCBStub.remoteHash.Val || SYNQueue[w].wDestPort == MyTCBStub.sslTxHead)
  2430:                                         #else
  2431:                                         if(SYNQueue[w].wDestPort == MyTCBStub.remoteHash.Val)
  2432:                                         #endif
  2433:                                         {
  2434:                                                 // Set up our socket and generate a reponse SYN+ACK packet
  2435:                                                 SyncTCB();
  2436:                                                 
  2437:                                                 #if defined(STACK_USE_SSL_SERVER)
  2438:                                                 // If this matches the SSL port, make sure that can be configured
  2439:                                                 // before continuing.  If not, break and leave this in the queue
  2440:                                                 if(SYNQueue[w].wDestPort == MyTCBStub.sslTxHead && !TCPStartSSLServer(hTCP))
  2441:                                                         break;
  2442:                                                 #endif
  2443:                                                 
  2444:                                                 memcpy((void*)&MyTCB.remote.niRemoteMACIP, (void*)&SYNQueue[w].niSourceAddress, sizeof(NODE_INFO));
  2445:                                                 MyTCB.remotePort.Val = SYNQueue[w].wSourcePort;
  2446:                                                 MyTCB.RemoteSEQ = SYNQueue[w].dwSourceSEQ + 1;
  2447:                                                 MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1] + MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val;
  2448:                                                 vFlags = SYN | ACK;
  2449:                                                 MyTCBStub.smState = TCP_SYN_RECEIVED;
  2450:                                                 
  2451:                                                 // Delete this SYN from the SYNQueue and compact the SYNQueue[] array
  2452:                                                 TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE));
  2453:                                                 SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort = 0u;
  2454:         
  2455:                                                 break;
  2456:                                         }
  2457:                                 }
  2458:                         }
  2459:                 #endif
  2460: 
  2461:                 if(vFlags)
  2462:                         SendTCP(vFlags, bRetransmit ? 0 : SENDTCP_RESET_TIMERS);
  2463: 
  2464:                 // The TCP_CLOSED, TCP_LISTEN, and sometimes the TCP_ESTABLISHED 
  2465:                 // state don't need any timeout events, so see if the timer is enabled
  2466:                 if(!MyTCBStub.Flags.bTimerEnabled)
  2467:                 {
  2468:                         #if defined(TCP_KEEP_ALIVE_TIMEOUT)
  2469:                                 // Only the established state has any use for keep-alives
  2470:                                 if(MyTCBStub.smState == TCP_ESTABLISHED)
  2471:                                 {
  2472:                                         // If timeout has not occured, do not do anything.
  2473:                                         if((LONG)(TickGet() - MyTCBStub.eventTime) < (LONG)0)
  2474:                                                 continue;
  2475:                 
  2476:                                         // If timeout has occured and the connection appears to be dead (no 
  2477:                                         // responses from remote node at all), close the connection so the 
  2478:                                         // application doesn't sit around indefinitely with a useless socket 
  2479:                                         // that it thinks is still open
  2480:                                         if(MyTCBStub.Flags.vUnackedKeepalives == TCP_MAX_UNACKED_KEEP_ALIVES)
  2481:                                         {
  2482:                                                 vFlags = MyTCBStub.Flags.bServer;
  2483: 
  2484:                                                 // Force an immediate FIN and RST transmission
  2485:                                                 // Double calling TCPDisconnect() will also place us 
  2486:                                                 // back in the listening state immediately if a server socket.
  2487:                                                 TCPDisconnect(hTCP);
  2488:                                                 TCPDisconnect(hTCP);
  2489:                                                 
  2490:                                                 // Prevent client mode sockets from getting reused by other applications.  
  2491:                                                 // The application must call TCPDisconnect() with the handle to free this 
  2492:                                                 // socket (and the handle associated with it)
  2493:                                                 if(!vFlags)
  2494:                                                         MyTCBStub.smState = TCP_CLOSED_BUT_RESERVED;
  2495:                                                 
  2496:                                                 continue;
  2497:                                         }
  2498:                                         
  2499:                                         // Otherwise, if a timeout occured, simply send a keep-alive packet
  2500:                                         SyncTCB();
  2501:                                         SendTCP(ACK, SENDTCP_KEEP_ALIVE);
  2502:                                         MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT;
  2503:                                 }
  2504:                         #endif
  2505:                         continue;
  2506:                 }
  2507: 
  2508:                 // If timeout has not occured, do not do anything.
  2509:                 if((LONG)(TickGet() - MyTCBStub.eventTime) < (LONG)0)
  2510:                         continue;
  2511: 
  2512:                 // Load up extended TCB information
  2513:                 SyncTCB();
  2514: 
  2515:                 // A timeout has occured.  Respond to this timeout condition
  2516:                 // depending on what state this socket is in.
  2517:                 switch(MyTCBStub.smState)
  2518:                 {
  2519:                         #if defined(STACK_CLIENT_MODE)
  2520:                         #if defined(STACK_USE_DNS)
  2521:                         case TCP_GET_DNS_MODULE:
  2522:                                 if(DNSBeginUsage())
  2523:                                 {
  2524:                                         MyTCBStub.smState = TCP_DNS_RESOLVE;
  2525:                                         if(MyTCB.flags.bRemoteHostIsROM)
  2526:                                                 DNSResolveROM((ROM BYTE*)(ROM_PTR_BASE)MyTCB.remote.dwRemoteHost, DNS_TYPE_A);
  2527:                                         else
  2528:                                                 DNSResolve((BYTE*)(PTR_BASE)MyTCB.remote.dwRemoteHost, DNS_TYPE_A);
  2529:                                 }
  2530:                                 break;
  2531:                                 
  2532:                         case TCP_DNS_RESOLVE:
  2533:                         {
  2534:                                 IP_ADDR ipResolvedDNSIP;
  2535: 
  2536:                                 // See if DNS resolution has finished.  Note that if the DNS 
  2537:                                 // fails, the &ipResolvedDNSIP will be written with 0x00000000. 
  2538:                                 // MyTCB.remote.dwRemoteHost is unioned with 
  2539:                                 // MyTCB.remote.niRemoteMACIP.IPAddr, so we can't directly write 
  2540:                                 // the DNS result into MyTCB.remote.niRemoteMACIP.IPAddr.  We 
  2541:                                 // must copy it over only if the DNS is resolution step was 
  2542:                                 // successful.
  2543:                                 if(DNSIsResolved(&ipResolvedDNSIP))
  2544:                                 {
  2545:                                         if(DNSEndUsage())
  2546:                                         {
  2547:                                                 MyTCB.remote.niRemoteMACIP.IPAddr.Val = ipResolvedDNSIP.Val;
  2548:                                                 MyTCBStub.smState = TCP_GATEWAY_SEND_ARP;
  2549:                                                 MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1]+MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val;
  2550:                                                 MyTCB.retryCount = 0;
  2551:                                                 MyTCB.retryInterval = (TICK_SECOND/4)/256;
  2552:                                         }
  2553:                                         else
  2554:                                         {
  2555:                                                 MyTCBStub.eventTime = TickGet() + 10*TICK_SECOND;
  2556:                                                 MyTCBStub.smState = TCP_GET_DNS_MODULE;
  2557:                                         }
  2558:                                 }
  2559:                                 break;
  2560:                         }
  2561:                         #endif // #if defined(STACK_USE_DNS)
  2562:                                 
  2563:                         case TCP_GATEWAY_SEND_ARP:
  2564:                                 // Obtain the MAC address associated with the server's IP address (either direct MAC address on same subnet, or the MAC address of the Gateway machine)
  2565:                                 MyTCBStub.eventTime2 = (WORD)TickGetDiv256();
  2566:                                 ARPResolve(&MyTCB.remote.niRemoteMACIP.IPAddr);
  2567:                                 MyTCBStub.smState = TCP_GATEWAY_GET_ARP;
  2568:                                 break;
  2569: 
  2570:                         case TCP_GATEWAY_GET_ARP:
  2571:                                 // Wait for the MAC address to finish being obtained
  2572:                                 if(!ARPIsResolved(&MyTCB.remote.niRemoteMACIP.IPAddr, &MyTCB.remote.niRemoteMACIP.MACAddr))
  2573:                                 {
  2574:                                         // Time out if too much time is spent in this state
  2575:                                         // Note that this will continuously send out ARP 
  2576:                                         // requests for an infinite time if the Gateway 
  2577:                                         // never responds
  2578:                                         if((WORD)TickGetDiv256() - MyTCBStub.eventTime2 > (WORD)MyTCB.retryInterval)
  2579:                                         {
  2580:                                                 // Exponentially increase timeout until we reach 6 attempts then stay constant
  2581:                                                 if(MyTCB.retryCount < 6u)
  2582:                                                 {
  2583:                                                         MyTCB.retryCount++;
  2584:                                                         MyTCB.retryInterval <<= 1;
  2585:                                                 }
  2586: 
  2587:                                                 // Retransmit ARP request
  2588:                                                 MyTCBStub.smState = TCP_GATEWAY_SEND_ARP;
  2589:                                         }
  2590:                                         break;
  2591:                                 }
  2592:                                 
  2593:                                 // Send out SYN connection request to remote node
  2594:                                 // This automatically disables the Timer from 
  2595:                                 // continuously firing for this socket
  2596:                                 vFlags = SYN;
  2597:                                 bRetransmit = FALSE;
  2598:                                 MyTCBStub.smState = TCP_SYN_SENT;
  2599:                                 break;
  2600:                         #endif // #if defined(STACK_CLIENT_MODE)
  2601:                         
  2602:                         case TCP_SYN_SENT:
  2603:                                 // Keep sending SYN until we hear from remote node.
  2604:                                 // This may be for infinite time, in that case
  2605:                                 // caller must detect it and do something.
  2606:                                 vFlags = SYN;
  2607:                                 bRetransmit = TRUE;
  2608: 
  2609:                                 // Exponentially increase timeout until we reach TCP_MAX_RETRIES attempts then stay constant
  2610:                                 if(MyTCB.retryCount >= (TCP_MAX_RETRIES - 1))
  2611:                                 {
  2612:                                         MyTCB.retryCount = TCP_MAX_RETRIES - 1;
  2613:                                         MyTCB.retryInterval = TCP_START_TIMEOUT_VAL<<(TCP_MAX_RETRIES-1);
  2614:                                 }
  2615:                                 break;
  2616:         
  2617:                         case TCP_SYN_RECEIVED:
  2618:                                 // We must receive ACK before timeout expires.
  2619:                                 // If not, resend SYN+ACK.
  2620:                                 // Abort, if maximum attempts counts are reached.
  2621:                                 if(MyTCB.retryCount < TCP_MAX_SYN_RETRIES)
  2622:                                 {
  2623:                                         vFlags = SYN | ACK;
  2624:                                         bRetransmit = TRUE;
  2625:                                 }
  2626:                                 else
  2627:                                 {
  2628:                                         if(MyTCBStub.Flags.bServer)
  2629:                                         {
  2630:                                                 vFlags = RST | ACK;
  2631:                                                 bCloseSocket = TRUE;
  2632:                                         }
  2633:                                         else
  2634:                                         {
  2635:                                                 vFlags = SYN;
  2636:                                         }
  2637:                                 }
  2638:                                 break;
  2639:         
  2640:                         case TCP_ESTABLISHED:
  2641:                         case TCP_CLOSE_WAIT:
  2642:                                 // Retransmit any unacknowledged data
  2643:                                 if(MyTCB.retryCount < TCP_MAX_RETRIES)
  2644:                                 {
  2645:                                         vFlags = ACK;
  2646:                                         bRetransmit = TRUE;
  2647:                                 }
  2648:                                 else
  2649:                                 {
  2650:                                         // No response back for too long, close connection
  2651:                                         // This could happen, for instance, if the communication 
  2652:                                         // medium was lost
  2653:                                         MyTCBStub.smState = TCP_FIN_WAIT_1;
  2654:                                         vFlags = FIN | ACK;
  2655:                                 }
  2656:                                 break;
  2657:         
  2658:                         case TCP_FIN_WAIT_1:
  2659:                                 if(MyTCB.retryCount < TCP_MAX_RETRIES)
  2660:                                 {
  2661:                                         // Send another FIN
  2662:                                         vFlags = FIN | ACK;
  2663:                                         bRetransmit = TRUE;
  2664:                                 }
  2665:                                 else
  2666:                                 {
  2667:                                         // Close on our own, we can't seem to communicate 
  2668:                                         // with the remote node anymore
  2669:                                         vFlags = RST | ACK;
  2670:                                         bCloseSocket = TRUE;
  2671:                                 }
  2672:                                 break;
  2673:         
  2674:                         case TCP_FIN_WAIT_2:
  2675:                                 // Close on our own, we can't seem to communicate 
  2676:                                 // with the remote node anymore
  2677:                                 vFlags = RST | ACK;
  2678:                                 bCloseSocket = TRUE;
  2679:                                 break;
  2680: 
  2681:                         case TCP_CLOSING:
  2682:                                 if(MyTCB.retryCount < TCP_MAX_RETRIES)
  2683:                                 {
  2684:                                         // Send another ACK+FIN (the FIN is retransmitted 
  2685:                                         // automatically since it hasn't been acknowledged by 
  2686:                                         // the remote node yet)
  2687:                                         vFlags = ACK;
  2688:                                         bRetransmit = TRUE;
  2689:                                 }
  2690:                                 else
  2691:                                 {
  2692:                                         // Close on our own, we can't seem to communicate 
  2693:                                         // with the remote node anymore
  2694:                                         vFlags = RST | ACK;
  2695:                                         bCloseSocket = TRUE;
  2696:                                 }
  2697:                                 break;
  2698:         
  2699: //                      case TCP_TIME_WAIT:
  2700: //                              // Wait around for a while (2MSL) and then goto closed state
  2701: //                              bCloseSocket = TRUE;
  2702: //                              break;
  2703: //                      
  2704: 
  2705:                         case TCP_LAST_ACK:
  2706:                                 // Send some more FINs or close anyway
  2707:                                 if(MyTCB.retryCount < TCP_MAX_RETRIES)
  2708:                                 {
  2709:                                         vFlags = FIN | ACK;
  2710:                                         bRetransmit = TRUE;
  2711:                                 }
  2712:                                 else
  2713:                                 {
  2714:                                         vFlags = RST | ACK;
  2715:                                         bCloseSocket = TRUE;
  2716:                                 }
  2717:                                 break;
  2718:                         
  2719:                         default:
  2720:                                 break;
  2721:                 }
  2722: 
  2723:                 if(vFlags)
  2724:                 {
  2725:                         // Transmit all unacknowledged data over again
  2726:                         if(bRetransmit)
  2727:                         {
  2728:                                 // Set the appropriate retry time
  2729:                                 MyTCB.retryCount++;
  2730:                                 MyTCB.retryInterval <<= 1;
  2731:                 
  2732:                                 // Calculate how many bytes we have to roll back and retransmit
  2733:                                 w = MyTCB.txUnackedTail - MyTCBStub.txTail;
  2734:                                 if(MyTCB.txUnackedTail < MyTCBStub.txTail)
  2735:                                         w += MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart;
  2736:                                 
  2737:                                 // Perform roll back of local SEQuence counter, remote window 
  2738:                                 // adjustment, and cause all unacknowledged data to be 
  2739:                                 // retransmitted by moving the unacked tail pointer.
  2740:                                 MyTCB.MySEQ -= w;
  2741:                                 MyTCB.remoteWindow += w;
  2742:                                 MyTCB.txUnackedTail = MyTCBStub.txTail;         
  2743:                                 SendTCP(vFlags, 0);
  2744:                         }
  2745:                         else
  2746:                                 SendTCP(vFlags, SENDTCP_RESET_TIMERS);
  2747: 
  2748:                 }
  2749:                 
  2750:                 if(bCloseSocket)
  2751:                         CloseSocket();
  2752:         }
  2753:         
  2754:         
  2755:         #if TCP_SYN_QUEUE_MAX_ENTRIES
  2756:                 // Process SYN Queue entry timeouts
  2757:                 for(w = 0; w < TCP_SYN_QUEUE_MAX_ENTRIES; w++)
  2758:                 {
  2759:                         // Abort search if there are no more valid records
  2760:                         if(SYNQueue[w].wDestPort == 0u)
  2761:                                 break;
  2762:                         
  2763:                         // See if this SYN has timed out
  2764:                         if((WORD)TickGetDiv256() - SYNQueue[w].wTimestamp > (WORD)(TCP_SYN_QUEUE_TIMEOUT/256ull))
  2765:                         {
  2766:                                 // Delete this SYN from the SYNQueue and compact the SYNQueue[] array
  2767:                                 TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE));
  2768:                                 SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort = 0u;
  2769:         
  2770:                                 // Since we deleted an entry, we need to roll back one 
  2771:                                 // index so next loop will process the correct record
  2772:                                 w--;    
  2773:                         }
  2774:                 }
  2775:         #endif
  2776: }
  2777: 
  2778: 
  2779: /*****************************************************************************
  2780:   Function:
  2781:         BOOL TCPProcess(NODE_INFO* remote, IP_ADDR* localIP, WORD len)
  2782: 
  2783:   Summary:
  2784:         Handles incoming TCP segments.
  2785: 
  2786:   Description:
  2787:         This function handles incoming TCP segments.  When a segment arrives, it
  2788:         is compared to open sockets using a hash of the remote port and IP.  
  2789:         On a match, the data is passed to HandleTCPSeg for further processing.
  2790: 
  2791:   Precondition:
  2792:         TCP is initialized and a TCP segment is ready in the MAC buffer.
  2793: 
  2794:   Parameters:
  2795:         remote - Remote NODE_INFO structure
  2796:         localIP - This stack's IP address (for header checking)
  2797:         len - Total length of the waiting TCP segment
  2798: 
  2799:   Return Values:
  2800:         TRUE - the segment was properly handled.
  2801:         FALSE - otherwise
  2802:   ***************************************************************************/
  2803: BOOL TCPProcess(NODE_INFO* remote, IP_ADDR* localIP, WORD len)
  2804: {
  2805:         TCP_HEADER      TCPHeader;
  2806:         PSEUDO_HEADER   pseudoHeader;
  2807:         WORD_VAL        checksum1;
  2808:         WORD_VAL        checksum2;
  2809:         BYTE            optionsSize;
  2810: 
  2811:         // Calculate IP pseudoheader checksum.
  2812:         pseudoHeader.SourceAddress      = remote->IPAddr;
  2813:         pseudoHeader.DestAddress        = *localIP;
  2814:         pseudoHeader.Zero               = 0x0;
  2815:         pseudoHeader.Protocol           = IP_PROT_TCP;
  2816:         pseudoHeader.Length             = len;
  2817: 
  2818:         SwapPseudoHeader(pseudoHeader);
  2819: 
  2820:         checksum1.Val = ~CalcIPChecksum((BYTE*)&pseudoHeader,
  2821:                 sizeof(pseudoHeader));
  2822: 
  2823:         // Now calculate TCP packet checksum in NIC RAM - should match
  2824:         // pesudo header checksum
  2825:         checksum2.Val = CalcIPBufferChecksum(len);
  2826: 
  2827:         // Compare checksums.
  2828:         if(checksum1.Val != checksum2.Val)
  2829:         {
  2830:                 MACDiscardRx();
  2831:                 return TRUE;
  2832:         }
  2833: 
  2834: #if defined(DEBUG_GENERATE_RX_LOSS)
  2835:         // Throw RX packets away randomly
  2836:         if(LFSRRand() > DEBUG_GENERATE_RX_LOSS)
  2837:         {
  2838:                 MACDiscardRx();
  2839:                 return TRUE;
  2840:         }
  2841: #endif
  2842: 
  2843:         // Retrieve TCP header.
  2844:         IPSetRxBuffer(0);
  2845:         MACGetArray((BYTE*)&TCPHeader, sizeof(TCPHeader));
  2846:         SwapTCPHeader(&TCPHeader);
  2847: 
  2848: 
  2849:         // Skip over options to retrieve data bytes
  2850:         optionsSize = (BYTE)((TCPHeader.DataOffset.Val << 2)-
  2851:                 sizeof(TCPHeader));
  2852:         len = len - optionsSize - sizeof(TCPHeader);
  2853: 
  2854:         // Find matching socket.
  2855:         if(FindMatchingSocket(&TCPHeader, remote))
  2856:         {
  2857:                 #if defined(STACK_USE_SSL)
  2858:                 PTR_BASE prevRxHead;
  2859:                 // For SSL connections, show HandleTCPSeg() the full data buffer
  2860:                 prevRxHead = MyTCBStub.rxHead;
  2861:                 if(MyTCBStub.sslStubID != SSL_INVALID_ID)
  2862:                         MyTCBStub.rxHead = MyTCBStub.sslRxHead;
  2863:                 #endif
  2864:                 
  2865:                 HandleTCPSeg(&TCPHeader, len);
  2866:                 
  2867:                 #if defined(STACK_USE_SSL)
  2868:                 if(MyTCBStub.sslStubID != SSL_INVALID_ID)
  2869:                 {
  2870:                         // Restore the buffer state
  2871:                         MyTCBStub.sslRxHead = MyTCBStub.rxHead;
  2872:                         MyTCBStub.rxHead = prevRxHead;
  2873: 
  2874:                         // Process the new SSL data, using the currently loaded stub
  2875:                         TCPSSLHandleIncoming(hCurrentTCP);
  2876:                 }
  2877:                 #endif
  2878:         }
  2879: //      else
  2880: //      {
  2881: //              // NOTE: RFC 793 specifies that if the socket is closed and a segment 
  2882: //              // arrives, we should send back a RST if the RST bit in the incoming 
  2883: //              // packet is not set.  Instead, we will just silently ignore such a 
  2884: //              // packet since this is what firewalls do on purpose to enhance 
  2885: //              // security.
  2886: //              //if(!TCPHeader.Flags.bits.flagRST)
  2887: //              //      SendTCP(RST, SENDTCP_RESET_TIMERS);
  2888: //      }
  2889: 
  2890:         // Finished with this packet, discard it and free the Ethernet RAM for new packets
  2891:         MACDiscardRx();
  2892: 
  2893:         return TRUE;
  2894: }
  2895: 
  2896: 
  2897: /*****************************************************************************
  2898:   Function:
  2899:         static void SendTCP(BYTE vTCPFlags, BYTE vSendFlags)
  2900: 
  2901:   Summary:
  2902:         Transmits a TPC segment.
  2903: 
  2904:   Description:
  2905:         This function assembles and transmits a TCP segment, including any 
  2906:         pending data.  It also supports retransmissions, keep-alives, and 
  2907:         other packet types.
  2908: 
  2909:   Precondition:
  2910:         TCP is initialized.
  2911: 
  2912:   Parameters:
  2913:         vTCPFlags - Additional TCP flags to include
  2914:         vSendFlags - Any combinations of SENDTCP_* constants to modify the
  2915:                                  transmit behavior or contents.
  2916: 
  2917:   Returns:
  2918:         None
  2919:   ***************************************************************************/
  2920: static void SendTCP(BYTE vTCPFlags, BYTE vSendFlags)
  2921: {
  2922:         WORD_VAL        wVal;
  2923:         TCP_HEADER      header;
  2924:         TCP_OPTIONS     options;
  2925:         PSEUDO_HEADER   pseudoHeader;
  2926:         WORD                    len;
  2927:         
  2928:         SyncTCB();
  2929: 
  2930:         // FINs must be handled specially
  2931:         if(vTCPFlags & FIN)
  2932:         {
  2933:                 MyTCBStub.Flags.bTXFIN = 1;
  2934:                 vTCPFlags &= ~FIN;
  2935:         }
  2936: 
  2937:         // Status will now be synched, disable automatic future 
  2938:         // status transmissions
  2939:         MyTCBStub.Flags.bTimer2Enabled = 0;
  2940:         MyTCBStub.Flags.bDelayedACKTimerEnabled = 0;
  2941:         MyTCBStub.Flags.bOneSegmentReceived = 0;
  2942:         MyTCBStub.Flags.bTXASAP = 0;
  2943:         MyTCBStub.Flags.bTXASAPWithoutTimerReset = 0;
  2944:         MyTCBStub.Flags.bHalfFullFlush = 0;
  2945: 
  2946:         //  Make sure that we can write to the MAC transmit area
  2947:         while(!IPIsTxReady());
  2948: 
  2949:         // Put all socket application data in the TX space
  2950:         if(vTCPFlags & (SYN | RST))
  2951:         {
  2952:                 // Don't put any data in SYN and RST messages
  2953:                 len = 0;
  2954:         }
  2955:         else
  2956:         {
  2957:                 // Begin copying any application data over to the TX space
  2958:                 if(MyTCBStub.txHead == MyTCB.txUnackedTail)
  2959:                 {
  2960:                         // All caught up on data TX, no real data for this packet
  2961:                         len = 0;
  2962:                 }
  2963:                 else if(MyTCBStub.txHead > MyTCB.txUnackedTail)
  2964:                 {
  2965:                         len = MyTCBStub.txHead - MyTCB.txUnackedTail;
  2966: 
  2967:                         if(len > MyTCB.remoteWindow)
  2968:                                 len = MyTCB.remoteWindow;
  2969: 
  2970:                         if(len > MyTCB.wRemoteMSS)
  2971:                         {
  2972:                                 len = MyTCB.wRemoteMSS;
  2973:                                 MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1;
  2974:                         }
  2975: 
  2976:                         // Copy application data into the raw TX buffer
  2977:                         TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER), TCP_ETH_RAM, MyTCB.txUnackedTail, MyTCBStub.vMemoryMedium, len);
  2978:                         MyTCB.txUnackedTail += len;
  2979:                 }
  2980:                 else
  2981:                 {
  2982:                         pseudoHeader.Length = MyTCBStub.bufferRxStart - MyTCB.txUnackedTail;
  2983:                         len = pseudoHeader.Length + MyTCBStub.txHead - MyTCBStub.bufferTxStart;
  2984: 
  2985:                         if(len > MyTCB.remoteWindow)
  2986:                                 len = MyTCB.remoteWindow;
  2987: 
  2988:                         if(len > MyTCB.wRemoteMSS)
  2989:                         {
  2990:                                 len = MyTCB.wRemoteMSS;
  2991:                                 MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1;
  2992:                         }
  2993: 
  2994:                         if(pseudoHeader.Length > len)
  2995:                                 pseudoHeader.Length = len;
  2996: 
  2997:                         // Copy application data into the raw TX buffer
  2998:                         TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER), TCP_ETH_RAM, MyTCB.txUnackedTail, MyTCBStub.vMemoryMedium, pseudoHeader.Length);
  2999:                         pseudoHeader.Length = len - pseudoHeader.Length;
  3000:         
  3001:                         // Copy any left over chunks of application data over
  3002:                         if(pseudoHeader.Length)
  3003:                         {
  3004:                                 TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER)+(MyTCBStub.bufferRxStart-MyTCB.txUnackedTail), TCP_ETH_RAM, MyTCBStub.bufferTxStart, MyTCBStub.vMemoryMedium, pseudoHeader.Length);
  3005:                         }
  3006: 
  3007:                         MyTCB.txUnackedTail += len;
  3008:                         if(MyTCB.txUnackedTail >= MyTCBStub.bufferRxStart)
  3009:                                 MyTCB.txUnackedTail -= MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart;
  3010:                 }
  3011: 
  3012:                 // If we are to transmit a FIN, make sure we can put one in this packet
  3013:                 if(MyTCBStub.Flags.bTXFIN)
  3014:                 {
  3015:                         if((len != MyTCB.remoteWindow) && (len != MyTCB.wRemoteMSS))
  3016:                                 vTCPFlags |= FIN;
  3017:                 }
  3018:         }
  3019: 
  3020:         // Ensure that all packets with data of some kind are 
  3021:         // retransmitted by TCPTick() until acknowledged
  3022:         // Pure ACK packets with no data are not ACKed back in TCP
  3023:         if(len || (vTCPFlags & (SYN | FIN)))
  3024:         {
  3025:                 // Transmitting data, update remote window variable to reflect smaller 
  3026:                 // window.
  3027:                 MyTCB.remoteWindow -= len;
  3028: 
  3029:                 // Push (PSH) all data for enhanced responsiveness on 
  3030:                 // the remote end, especially with GUIs
  3031:                 if(len)
  3032:                         vTCPFlags |= PSH;
  3033: 
  3034:                 if(vSendFlags & SENDTCP_RESET_TIMERS)
  3035:                 {
  3036:                         MyTCB.retryCount = 0;
  3037:                         MyTCB.retryInterval = TCP_START_TIMEOUT_VAL;
  3038:                 }       
  3039: 
  3040:                 MyTCBStub.eventTime = TickGet() + MyTCB.retryInterval;
  3041:                 MyTCBStub.Flags.bTimerEnabled = 1;
  3042:         }
  3043:         else if(vSendFlags & SENDTCP_KEEP_ALIVE)
  3044:         {
  3045:                 // Increment Keep Alive TX counter to handle disconnection if not response is returned
  3046:                 MyTCBStub.Flags.vUnackedKeepalives++;
  3047:                 
  3048:                 // Generate a dummy byte
  3049:                 MyTCB.MySEQ -= 1;
  3050:                 len = 1;
  3051:         }
  3052:         else if(MyTCBStub.Flags.bTimerEnabled) 
  3053:         {
  3054:                 // If we have data to transmit, but the remote RX window is zero, 
  3055:                 // so we aren't transmitting any right now then make sure to not 
  3056:                 // extend the retry counter or timer.  This will stall our TX 
  3057:                 // with a periodic ACK sent to the remote node.
  3058:                 if(!(vSendFlags & SENDTCP_RESET_TIMERS))
  3059:                 {
  3060:                         // Roll back retry counters since we can't send anything, 
  3061:                         // but only if we incremented it in the first place
  3062:                         if(MyTCB.retryCount)
  3063:                         {
  3064:                                 MyTCB.retryCount--;
  3065:                                 MyTCB.retryInterval >>= 1;
  3066:                         }
  3067:                 }
  3068:         
  3069:                 MyTCBStub.eventTime = TickGet() + MyTCB.retryInterval;
  3070:         }
  3071:         
  3072: 
  3073:         header.SourcePort                       = MyTCB.localPort.Val;
  3074:         header.DestPort                         = MyTCB.remotePort.Val;
  3075:         header.SeqNumber                        = MyTCB.MySEQ;
  3076:         header.AckNumber                        = MyTCB.RemoteSEQ;
  3077:         header.Flags.bits.Reserved2     = 0;
  3078:         header.DataOffset.Reserved3     = 0;
  3079:         header.Flags.byte                       = vTCPFlags;
  3080:         header.UrgentPointer        = 0;
  3081: 
  3082:         // Update our send sequence number and ensure retransmissions 
  3083:         // of SYNs and FINs use the right sequence number
  3084:         MyTCB.MySEQ += (DWORD)len;
  3085:         if(vTCPFlags & SYN)
  3086:         {
  3087:                 // SEG.ACK needs to be zero for the first SYN packet for compatibility 
  3088:                 // with certain paranoid TCP/IP stacks, even though the ACK flag isn't 
  3089:                 // set (indicating that the AckNumber field is unused).
  3090:                 if(!(vTCPFlags & ACK))
  3091:                         header.AckNumber = 0x00000000;
  3092: 
  3093:                 if(MyTCB.flags.bSYNSent)
  3094:                         header.SeqNumber--;
  3095:                 else
  3096:                 {
  3097:                         MyTCB.MySEQ++;
  3098:                         MyTCB.flags.bSYNSent = 1;
  3099:                 }
  3100:         }
  3101:         if(vTCPFlags & FIN)
  3102:         {
  3103:                 if(MyTCB.flags.bFINSent)
  3104:                         header.SeqNumber--;
  3105:                 else
  3106:                 {
  3107:                         MyTCB.MySEQ++;
  3108:                         MyTCB.flags.bFINSent = 1;
  3109:                 }
  3110:         }
  3111: 
  3112:         // Calculate the amount of free space in the RX buffer area of this socket
  3113:         if(MyTCBStub.rxHead >= MyTCBStub.rxTail)
  3114:                 header.Window = (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart) - (MyTCBStub.rxHead - MyTCBStub.rxTail);
  3115:         else
  3116:                 header.Window = MyTCBStub.rxTail - MyTCBStub.rxHead - 1;
  3117: 
  3118:         // Calculate the amount of free space in the MAC RX buffer area and adjust window if needed
  3119:         wVal.Val = MACGetFreeRxSize();
  3120:         if(wVal.Val < 64)
  3121:     {
  3122:                 wVal.Val = 0;
  3123:     }
  3124:     else
  3125:     {
  3126:                 wVal.Val -= 64;
  3127:     }
  3128:         // Force the remote node to throttle back if we are running low on general RX buffer space
  3129:         if(header.Window > wVal.Val)
  3130:                 header.Window = wVal.Val;
  3131: 
  3132:         SwapTCPHeader(&header);
  3133: 
  3134: 
  3135:         len += sizeof(header);
  3136:         header.DataOffset.Val   = sizeof(header) >> 2;
  3137: 
  3138:         // Insert the MSS (Maximum Segment Size) TCP option if this is SYN packet
  3139:         if(vTCPFlags & SYN)
  3140:         {
  3141:                 len += sizeof(options);
  3142:                 options.Kind = TCP_OPTIONS_MAX_SEG_SIZE;
  3143:                 options.Length = 0x04;
  3144: 
  3145:                 // Load MSS and swap to big endian
  3146:                 options.MaxSegSize.Val = (((TCP_MAX_SEG_SIZE_RX)&0x00FF)<<8) | (((TCP_MAX_SEG_SIZE_RX)&0xFF00)>>8);
  3147: 
  3148:                 header.DataOffset.Val   += sizeof(options) >> 2;
  3149:         }
  3150: 
  3151:         // Calculate IP pseudoheader checksum.
  3152:         pseudoHeader.SourceAddress      = AppConfig.MyIPAddr;
  3153:         pseudoHeader.DestAddress    = MyTCB.remote.niRemoteMACIP.IPAddr;
  3154:         pseudoHeader.Zero           = 0x0;
  3155:         pseudoHeader.Protocol       = IP_PROT_TCP;
  3156:         pseudoHeader.Length                     = len;
  3157:         SwapPseudoHeader(pseudoHeader);
  3158:         header.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader, sizeof(pseudoHeader));
  3159: 
  3160:         // Write IP header
  3161:         MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER));
  3162:         IPPutHeader(&MyTCB.remote.niRemoteMACIP, IP_PROT_TCP, len);
  3163:         MACPutArray((BYTE*)&header, sizeof(header));
  3164:         if(vTCPFlags & SYN)
  3165:                 MACPutArray((BYTE*)&options, sizeof(options));
  3166: 
  3167:         // Update the TCP checksum
  3168:         MACSetReadPtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER));
  3169:         wVal.Val = CalcIPBufferChecksum(len);
  3170: #if defined(DEBUG_GENERATE_TX_LOSS)
  3171:         // Damage TCP checksums on TX packets randomly
  3172:         if(LFSRRand() > DEBUG_GENERATE_TX_LOSS)
  3173:         {
  3174:                 wVal.Val++;
  3175:         }
  3176: #endif
  3177:         MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER) + 16);
  3178:         MACPutArray((BYTE*)&wVal, sizeof(WORD));
  3179: 
  3180:         // Physically start the packet transmission over the network
  3181:         MACFlush();
  3182: }
  3183: 
  3184: /*****************************************************************************
  3185:   Function:
  3186:         static BOOL FindMatchingSocket(TCP_HEADER* h, NODE_INFO* remote)
  3187: 
  3188:   Summary:
  3189:         Finds a suitable socket for a TCP segment.
  3190: 
  3191:   Description:
  3192:         This function searches through the sockets and attempts to match one with
  3193:         a given TCP header and NODE_INFO structure.  If a socket is found, its 
  3194:         index is saved in hCurrentTCP and the associated MyTCBStub and MyTCB are
  3195:         loaded. Otherwise, INVALID_SOCKET is placed in hCurrentTCP.
  3196:         
  3197:   Precondition:
  3198:         TCP is initialized.
  3199: 
  3200:   Parameters:
  3201:         h - TCP header to be matched against
  3202:         remote - The remote node who sent this header
  3203: 
  3204:   Return Values:
  3205:         TRUE - A match was found and is loaded in hCurrentTCP
  3206:         FALSE - No suitable socket was found and hCurrentTCP is INVALID_SOCKET
  3207:   ***************************************************************************/
  3208: static BOOL FindMatchingSocket(TCP_HEADER* h, NODE_INFO* remote)
  3209: {
  3210:         TCP_SOCKET hTCP;
  3211:         TCP_SOCKET partialMatch;
  3212:         WORD hash;
  3213: 
  3214:         // Prevent connections on invalid port 0
  3215:         if(h->DestPort == 0u)
  3216:                 return FALSE;
  3217: 
  3218:         partialMatch = INVALID_SOCKET;
  3219:         hash = (remote->IPAddr.w[1]+remote->IPAddr.w[0] + h->SourcePort) ^ h->DestPort;
  3220: 
  3221:         // Loop through all sockets looking for a socket that is expecting this 
  3222:         // packet or can handle it.
  3223:         for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++ )
  3224:         {
  3225:                 SyncTCBStub(hTCP);
  3226: 
  3227:                 if(MyTCBStub.smState == TCP_CLOSED)
  3228:                 {
  3229:                         continue;
  3230:                 }
  3231:                 else if(MyTCBStub.smState == TCP_LISTEN)
  3232:                 {// For listening ports, check if this is the correct port
  3233:                         if(MyTCBStub.remoteHash.Val == h->DestPort)
  3234:                                 partialMatch = hTCP;
  3235:                         
  3236:                         #if defined(STACK_USE_SSL_SERVER)
  3237:                         // Check the SSL port as well for SSL Servers
  3238:                         // 0 is defined as an invalid port number
  3239:                         if(MyTCBStub.sslTxHead == h->DestPort)
  3240:                                 partialMatch = hTCP;
  3241:                         #endif
  3242:                         
  3243:                         continue;
  3244:                 }
  3245:                 else if(MyTCBStub.remoteHash.Val != hash)
  3246:                 {// Ignore if the hash doesn't match
  3247:                         continue;
  3248:                 }
  3249: 
  3250:                 SyncTCB();
  3251:                 if(     h->DestPort == MyTCB.localPort.Val &&
  3252:                         h->SourcePort == MyTCB.remotePort.Val &&
  3253:                         remote->IPAddr.Val == MyTCB.remote.niRemoteMACIP.IPAddr.Val)
  3254:                 {
  3255:                         return TRUE;
  3256:                 }
  3257:         }
  3258: 
  3259: 
  3260:         // If there is a partial match, then a listening socket is currently 
  3261:         // available.  Set up the extended TCB with the info needed 
  3262:         // to establish a connection and return this socket to the 
  3263:         // caller.
  3264:         if(partialMatch != INVALID_SOCKET)
  3265:         {
  3266:                 SyncTCBStub(partialMatch);
  3267:                 SyncTCB();
  3268:         
  3269:                 // For SSL ports, begin the SSL Handshake
  3270:                 #if defined(STACK_USE_SSL_SERVER)
  3271:                 if(MyTCBStub.sslTxHead == h->DestPort)
  3272:                 {
  3273:                         // Try to start an SSL session.  If no stubs are available,
  3274:                         // we can't service this request right now, so ignore it.
  3275:                         if(!TCPStartSSLServer(partialMatch))
  3276:                                 partialMatch = INVALID_SOCKET;
  3277:                 }
  3278:                 #endif
  3279:         
  3280:                 // Make sure the above check didn't fail (this is unfortunately 
  3281:                 // redundant for non-SSL sockets).  Otherwise, fall out to below
  3282:                 // and add to the SYN queue.
  3283:                 if(partialMatch != INVALID_SOCKET)
  3284:                 {
  3285:                         MyTCBStub.remoteHash.Val = hash;
  3286:                 
  3287:                         memcpy((void*)&MyTCB.remote, (void*)remote, sizeof(NODE_INFO));
  3288:                         MyTCB.remotePort.Val = h->SourcePort;
  3289:                         MyTCB.localPort.Val = h->DestPort;
  3290:                         MyTCB.txUnackedTail     = MyTCBStub.bufferTxStart;
  3291:                 
  3292:                         // All done, and we have a match
  3293:                         return TRUE;
  3294:                 }
  3295:         }
  3296: 
  3297:         // No available sockets are listening on this port.  (Or, for
  3298:         // SSL requests, perhaps no SSL sessions were available.  However,
  3299:         // there may be a server socket which is currently busy but 
  3300:         // could handle this packet, so we should check.
  3301:         #if TCP_SYN_QUEUE_MAX_ENTRIES
  3302:         {
  3303:                 WORD wQueueInsertPos;
  3304:                 
  3305:                 // See if this is a SYN packet
  3306:                 if(!h->Flags.bits.flagSYN)
  3307:                         return FALSE;
  3308: 
  3309:                 // See if there is space in our SYN queue
  3310:                 if(SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort)
  3311:                         return FALSE;
  3312:                 
  3313:                 // See if we have this SYN already in our SYN queue.
  3314:                 // If not already in the queue, find out where we 
  3315:                 // should insert this SYN to the queue
  3316:                 for(wQueueInsertPos = 0; wQueueInsertPos < TCP_SYN_QUEUE_MAX_ENTRIES; wQueueInsertPos++)
  3317:                 {
  3318:                         // Exit loop if we found a free record
  3319:                         if(SYNQueue[wQueueInsertPos].wDestPort == 0u)
  3320:                                 break;
  3321: 
  3322:                         // Check if this SYN packet is already in the SYN queue
  3323:                         if(SYNQueue[wQueueInsertPos].wDestPort != h->DestPort)
  3324:                                 continue;
  3325:                         if(SYNQueue[wQueueInsertPos].wSourcePort != h->SourcePort)
  3326:                                 continue;
  3327:                         if(SYNQueue[wQueueInsertPos].niSourceAddress.IPAddr.Val != remote->IPAddr.Val)
  3328:                                 continue;
  3329: 
  3330:                         // SYN matches SYN queue entry.  Update timestamp and do nothing.
  3331:                         SYNQueue[wQueueInsertPos].wTimestamp = TickGetDiv256();
  3332:                         return FALSE;
  3333:                 }
  3334:                 
  3335:                 // Check to see if we have any server sockets which 
  3336:                 // are currently connected, but could handle this SYN 
  3337:                 // request at a later time if the client disconnects.
  3338:                 for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++)
  3339:                 {
  3340:                         SyncTCBStub(hTCP);
  3341:                         if(!MyTCBStub.Flags.bServer)
  3342:                                 continue;
  3343: 
  3344:                         SyncTCB();
  3345:                         #if defined(STACK_USE_SSL_SERVER)
  3346:                         if((MyTCB.localPort.Val != h->DestPort) && (MyTCB.localSSLPort.Val != h->DestPort))
  3347:                         #else
  3348:                         if(MyTCB.localPort.Val != h->DestPort)
  3349:                         #endif
  3350:                                 continue;
  3351: 
  3352:                         // Generate the SYN queue entry
  3353:                         memcpy((void*)&SYNQueue[wQueueInsertPos].niSourceAddress, (void*)remote, sizeof(NODE_INFO));
  3354:                         SYNQueue[wQueueInsertPos].wSourcePort = h->SourcePort;
  3355:                         SYNQueue[wQueueInsertPos].dwSourceSEQ = h->SeqNumber;
  3356:                         SYNQueue[wQueueInsertPos].wDestPort = h->DestPort;
  3357:                         SYNQueue[wQueueInsertPos].wTimestamp = TickGetDiv256();
  3358: 
  3359:                         return FALSE;
  3360:                 }
  3361:         }
  3362:         #endif
  3363:                 
  3364:         return FALSE;
  3365: 
  3366: }
  3367: 
  3368: 
  3369: 
  3370: /*****************************************************************************
  3371:   Function:
  3372:         static void SwapTCPHeader(TCP_HEADER* header)
  3373: 
  3374:   Summary:
  3375:         Swaps endian-ness of a TCP header.
  3376: 
  3377:   Description:
  3378:         This function swaps the endian-ness of a given TCP header for comparison.
  3379: 
  3380:   Precondition:
  3381:         None
  3382: 
  3383:   Parameters:
  3384:         header - The TCP header that is to be swapped
  3385: 
  3386:   Returns:
  3387:         None
  3388:   ***************************************************************************/
  3389: static void SwapTCPHeader(TCP_HEADER* header)
  3390: {
  3391:         header->SourcePort      = swaps(header->SourcePort);
  3392:         header->DestPort        = swaps(header->DestPort);
  3393:         header->SeqNumber       = swapl(header->SeqNumber);
  3394:         header->AckNumber       = swapl(header->AckNumber);
  3395:         header->Window          = swaps(header->Window);
  3396:         header->Checksum        = swaps(header->Checksum);
  3397:         header->UrgentPointer   = swaps(header->UrgentPointer);
  3398: }
  3399: 
  3400: 
  3401: 
  3402: /*****************************************************************************
  3403:   Function:
  3404:         static void CloseSocket(void)
  3405: 
  3406:   Summary:
  3407:         Closes a TCP socket.
  3408: 
  3409:   Description:
  3410:         This function closes a TCP socket.  All socket state information is 
  3411:         reset, and any buffered bytes are discarded.  The socket is no longer
  3412:         accessible by the application after this point.
  3413: 
  3414:   Precondition:
  3415:         The TCPStub corresponding to the socket to be closed is synced.
  3416: 
  3417:   Parameters:
  3418:         None
  3419: 
  3420:   Returns:
  3421:         None
  3422:   ***************************************************************************/
  3423: static void CloseSocket(void)
  3424: {
  3425:         SyncTCB();
  3426: 
  3427:         MyTCBStub.remoteHash.Val = MyTCB.localPort.Val;
  3428:         MyTCBStub.txHead = MyTCBStub.bufferTxStart;
  3429:         MyTCBStub.txTail = MyTCBStub.bufferTxStart;
  3430:         MyTCBStub.rxHead = MyTCBStub.bufferRxStart;
  3431:         MyTCBStub.rxTail = MyTCBStub.bufferRxStart;
  3432:         MyTCBStub.smState = MyTCBStub.Flags.bServer ? TCP_LISTEN : TCP_CLOSED;
  3433:         MyTCBStub.Flags.vUnackedKeepalives = 0;
  3434:         MyTCBStub.Flags.bTimerEnabled = 0;
  3435:         MyTCBStub.Flags.bTimer2Enabled = 0;
  3436:         MyTCBStub.Flags.bDelayedACKTimerEnabled = 0;
  3437:         MyTCBStub.Flags.bOneSegmentReceived = 0;
  3438:         MyTCBStub.Flags.bHalfFullFlush = 0;
  3439:         MyTCBStub.Flags.bTXASAP = 0;
  3440:         MyTCBStub.Flags.bTXASAPWithoutTimerReset = 0;
  3441:         MyTCBStub.Flags.bTXFIN = 0;
  3442:         MyTCBStub.Flags.bSocketReset = 1;
  3443: 
  3444:         #if defined(STACK_USE_SSL)
  3445:         // If SSL is active, then we need to close it
  3446:         if(MyTCBStub.sslStubID != SSL_INVALID_ID)
  3447:         {
  3448:                 SSLTerminate(MyTCBStub.sslStubID);
  3449:                 MyTCBStub.sslStubID = SSL_INVALID_ID;
  3450: 
  3451:                 // Swap the SSL port and local port back to proper values
  3452:                 MyTCBStub.remoteHash.Val = MyTCB.localSSLPort.Val;
  3453:                 MyTCB.localSSLPort.Val = MyTCB.localPort.Val;
  3454:                 MyTCB.localPort.Val = MyTCBStub.remoteHash.Val;
  3455:         }
  3456: 
  3457:         // Reset the SSL buffer pointers
  3458:         MyTCBStub.sslRxHead = MyTCBStub.bufferRxStart;
  3459:         MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
  3460:         #endif
  3461:         
  3462:         #if defined(STACK_USE_SSL_SERVER)
  3463:         MyTCBStub.sslTxHead = MyTCB.localSSLPort.Val;
  3464:         #endif
  3465: 
  3466:         MyTCB.flags.bFINSent = 0;
  3467:         MyTCB.flags.bSYNSent = 0;
  3468:         MyTCB.flags.bRXNoneACKed1 = 0;
  3469:         MyTCB.flags.bRXNoneACKed2 = 0;
  3470:         MyTCB.txUnackedTail = MyTCBStub.bufferTxStart;
  3471:         ((DWORD_VAL*)(&MyTCB.MySEQ))->w[0] = LFSRRand();
  3472:         ((DWORD_VAL*)(&MyTCB.MySEQ))->w[1] = LFSRRand();
  3473:         MyTCB.sHoleSize = -1;
  3474:         MyTCB.remoteWindow = 1;
  3475: }
  3476: 
  3477: 
  3478: /*****************************************************************************
  3479:   Function:
  3480:         static WORD GetMaxSegSizeOption(void)
  3481: 
  3482:   Summary:
  3483:         Obtains the Maximum Segment Size (MSS) TCP Option out of the TCP header 
  3484:         for the current socket.
  3485: 
  3486:   Description:
  3487:         Parses the current TCP packet header and extracts the Maximum Segment Size 
  3488:         option.  
  3489: 
  3490:   Precondition:
  3491:         Must be called while a TCP packet is present and being processed via 
  3492:         HandleTCPSeg() and only if the the TCP SYN flag is set.
  3493: 
  3494:   Parameters:
  3495:         None
  3496: 
  3497:   Returns:
  3498:         Maximum segment size option value.  If illegal or not present, a failsafe 
  3499:         value of 536 is returned.  If the option is larger than the 
  3500:         TCP_MAX_SEG_SIZE_TX upper limit, then TCP_MAX_SEG_SIZE_TX is returned.
  3501: 
  3502:   Remarks:
  3503:         The internal MAC Read Pointer is moved but not restored.
  3504:   ***************************************************************************/
  3505: static WORD GetMaxSegSizeOption(void)
  3506: {
  3507:         BYTE vOptionsBytes;
  3508:         BYTE vOption;
  3509:         WORD wMSS;
  3510: 
  3511:         // Find out how many options bytes are in this packet.
  3512:         IPSetRxBuffer(2+2+4+4); // Seek to data offset field, skipping Source port (2), Destination port (2), Sequence number (4), and Acknowledgement number (4)
  3513:         vOptionsBytes = MACGet();
  3514:         vOptionsBytes = ((vOptionsBytes&0xF0)>>2) - sizeof(TCP_HEADER);
  3515: 
  3516:         // Return minimum Maximum Segment Size value of 536 bytes if none are 
  3517:         // present
  3518:         if(vOptionsBytes == 0u)
  3519:                 return 536;
  3520:                 
  3521:         // Seek to beginning of options
  3522:         MACGetArray(NULL, 7);
  3523: 
  3524:         // Search for the Maximum Segment Size option   
  3525:         while(vOptionsBytes--)
  3526:         {
  3527:                 vOption = MACGet();
  3528:                 
  3529:                 if(vOption == 0u)       // End of Options list
  3530:                         break;
  3531:                 
  3532:                 if(vOption == 1u)       // NOP option
  3533:                         continue;
  3534:                         
  3535:                 if(vOption == 2u)       // Maximum Segment Size option
  3536:                 {
  3537:                         if(vOptionsBytes < 3u)
  3538:                                 break;
  3539: 
  3540:                         wMSS = 0;
  3541:                                 
  3542:                         // Get option length
  3543:                         vOption = MACGet();
  3544:                         if(vOption == 4u)
  3545:                         {// Retrieve MSS and swap value to little endian
  3546:                                 ((BYTE*)&wMSS)[1] = MACGet();
  3547:                                 ((BYTE*)&wMSS)[0] = MACGet();
  3548:                         }
  3549:                         
  3550:                         if(wMSS < 536u)
  3551:                                 break;
  3552:                         if(wMSS > TCP_MAX_SEG_SIZE_TX)
  3553:                                 return TCP_MAX_SEG_SIZE_TX;
  3554:                         else 
  3555:                                 return wMSS;
  3556:                 }
  3557:                 else
  3558:                 { // Assume this is a multi byte option and throw it way
  3559:                         if(vOptionsBytes < 2u)
  3560:                                 break;
  3561:                         vOption = MACGet();
  3562:                         if(vOptionsBytes < vOption)
  3563:                                 break;
  3564:                         MACGetArray(NULL, vOption);
  3565:                         vOptionsBytes -= vOption;
  3566:                 }
  3567:                 
  3568:         }
  3569:         
  3570:         // Did not find MSS option, return worst case default
  3571:         return 536;
  3572: }
  3573: 
  3574: /*****************************************************************************
  3575:   Function:
  3576:         static void HandleTCPSeg(TCP_HEADER* h, WORD len)
  3577: 
  3578:   Summary:
  3579:         Processes an incoming TCP segment.
  3580: 
  3581:   Description:
  3582:         Once an incoming segment has been matched to a socket, this function
  3583:         performs the necessary processing with the data.  Depending on the 
  3584:         segment and the state, this may include copying data to the TCP buffer,
  3585:         re-assembling out-of order packets, continuing an initialization or 
  3586:         closing handshake, or closing the socket altogether.
  3587: 
  3588:   Precondition:
  3589:         TCP is initialized and the current TCP stub is already synced.
  3590: 
  3591:   Parameters:
  3592:         h - The TCP header for this packet
  3593:         len - The total buffer length of this segment
  3594: 
  3595:   Returns:
  3596:         None
  3597:   ***************************************************************************/
  3598: static void HandleTCPSeg(TCP_HEADER* h, WORD len)
  3599: {
  3600:         DWORD dwTemp;
  3601:         PTR_BASE wTemp;
  3602:         LONG lMissingBytes;
  3603:         WORD wMissingBytes;
  3604:         WORD wFreeSpace;
  3605:         BYTE localHeaderFlags;
  3606:         DWORD localAckNumber;
  3607:         DWORD localSeqNumber;
  3608:         WORD wSegmentLength;
  3609:         BOOL bSegmentAcceptable;
  3610:         WORD wNewWindow;
  3611: 
  3612: 
  3613:         // Cache a few variables in local RAM.  
  3614:         // PIC18s take a fair amount of code and execution time to 
  3615:         // dereference pointers frequently.
  3616:         localHeaderFlags = h->Flags.byte;
  3617:         localAckNumber = h->AckNumber;
  3618:         localSeqNumber = h->SeqNumber;
  3619: 
  3620:         // We received a packet, reset the keep alive timer and count
  3621:         #if defined(TCP_KEEP_ALIVE_TIMEOUT)
  3622:                 MyTCBStub.Flags.vUnackedKeepalives = 0;
  3623:                 if(!MyTCBStub.Flags.bTimerEnabled)
  3624:                         MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT;
  3625:         #endif
  3626: 
  3627:         // Handle TCP_LISTEN and TCP_SYN_SENT states
  3628:         // Both of these states will return, so code following this 
  3629:         // state machine need not check explicitly for these two 
  3630:         // states.
  3631:         switch(MyTCBStub.smState)
  3632:         {
  3633:                 case TCP_LISTEN:
  3634:                         // First: check RST flag
  3635:                         if(localHeaderFlags & RST)
  3636:                         {
  3637:                                 CloseSocket();  // Unbind remote IP address/port info
  3638:                                 return;
  3639:                         }
  3640: 
  3641:                         // Second: check ACK flag, which would be invalid
  3642:                         if(localHeaderFlags & ACK)
  3643:                         {
  3644:                                 // Use a believable sequence number and reset the remote node
  3645:                                 MyTCB.MySEQ = localAckNumber;
  3646:                                 SendTCP(RST, 0);
  3647:                                 CloseSocket();  // Unbind remote IP address/port info
  3648:                                 return;
  3649:                         }
  3650: 
  3651:                         // Third: check for SYN flag, which is what we're looking for
  3652:                         if(localHeaderFlags & SYN)
  3653:                         {
  3654:                                 // We now have a sequence number for the remote node
  3655:                                 MyTCB.RemoteSEQ = localSeqNumber + 1;
  3656: 
  3657:                                 // Get MSS option
  3658:                                 MyTCB.wRemoteMSS = GetMaxSegSizeOption();
  3659: 
  3660:                                 // Set Initial Send Sequence (ISS) number
  3661:                                 // Nothing to do on this step... ISS already set in CloseSocket()
  3662:                                 
  3663:                                 // Respond with SYN + ACK
  3664:                                 SendTCP(SYN | ACK, SENDTCP_RESET_TIMERS);
  3665:                                 MyTCBStub.smState = TCP_SYN_RECEIVED;
  3666:                         }
  3667:                         else
  3668:                         {
  3669:                                 CloseSocket();  // Unbind remote IP address/port info
  3670:                         }
  3671: 
  3672:                         // Fourth: check for other text and control
  3673:                         // Nothing to do since we don't support this
  3674:                         return;
  3675: 
  3676:                 case TCP_SYN_SENT:
  3677:                         // Second: check the RST bit
  3678:                         // This is out of order because this stack has no API for 
  3679:                         // notifying the application that the connection seems to 
  3680:                         // be failing.  Instead, the application must time out and 
  3681:                         // the stack will just keep trying in the mean time.
  3682:                         if(localHeaderFlags & RST)
  3683:                                 return;
  3684: 
  3685:                         // First: check ACK bit
  3686:                         if(localHeaderFlags & ACK)
  3687:                         {
  3688:                                 if(localAckNumber != MyTCB.MySEQ)
  3689:                                 {
  3690:                                         // Send a RST packet with SEQ = SEG.ACK, but retain our SEQ 
  3691:                                         // number for arivial of any other SYN+ACK packets
  3692:                                         localSeqNumber = MyTCB.MySEQ;   // Save our original SEQ number
  3693:                                         MyTCB.MySEQ = localAckNumber;   // Set SEQ = SEG.ACK
  3694:                                         SendTCP(RST, SENDTCP_RESET_TIMERS);             // Send the RST
  3695:                                         MyTCB.MySEQ = localSeqNumber;   // Restore original SEQ number
  3696:                                         return;
  3697:                                 }
  3698:                         }
  3699: 
  3700:                         // Third: check the security and precedence
  3701:                         // No such feature in this stack.  We want to accept all connections.
  3702: 
  3703:                         // Fourth: check the SYN bit
  3704:                         if(localHeaderFlags & SYN)
  3705:                         {
  3706:                                 // We now have an initial sequence number and window size
  3707:                                 MyTCB.RemoteSEQ = localSeqNumber + 1;
  3708:                                 MyTCB.remoteWindow = h->Window;
  3709: 
  3710:                                 // Get MSS option
  3711:                                 MyTCB.wRemoteMSS = GetMaxSegSizeOption();
  3712: 
  3713:                                 if(localHeaderFlags & ACK)
  3714:                                 {
  3715:                                         SendTCP(ACK, SENDTCP_RESET_TIMERS);
  3716:                                         MyTCBStub.smState = TCP_ESTABLISHED;
  3717:                                         // Set up keep-alive timer
  3718:                                         #if defined(TCP_KEEP_ALIVE_TIMEOUT)
  3719:                                                 MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT;
  3720:                                         #endif
  3721:                                         MyTCBStub.Flags.bTimerEnabled = 0;
  3722:                                 }
  3723:                                 else
  3724:                                 {
  3725:                                         SendTCP(SYN | ACK, SENDTCP_RESET_TIMERS);
  3726:                                         MyTCBStub.smState = TCP_SYN_RECEIVED;
  3727:                                 }
  3728:                         }
  3729: 
  3730:                         // Fifth: drop the segment if neither SYN or RST is set
  3731:                         return;
  3732: 
  3733:                 default:
  3734:                         break;
  3735:         }
  3736: 
  3737:         //
  3738:         // First: check the sequence number
  3739:         //
  3740:         wSegmentLength = len;
  3741:         if(localHeaderFlags & FIN)
  3742:                 wSegmentLength++;
  3743:         if(localHeaderFlags & SYN)
  3744:                 wSegmentLength++;
  3745: 
  3746:         // Calculate the RX FIFO space
  3747:         if(MyTCBStub.rxHead >= MyTCBStub.rxTail)
  3748:                 wFreeSpace = (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart) - (MyTCBStub.rxHead - MyTCBStub.rxTail);
  3749:         else
  3750:                 wFreeSpace = MyTCBStub.rxTail - MyTCBStub.rxHead - 1;
  3751: 
  3752:         // Calculate the number of bytes ahead of our head pointer this segment skips
  3753:         lMissingBytes = localSeqNumber - MyTCB.RemoteSEQ;
  3754:         wMissingBytes = (WORD)lMissingBytes;
  3755:         
  3756:         // Run TCP acceptability tests to verify that this packet has a valid sequence number
  3757:         bSegmentAcceptable = FALSE;
  3758:         if(wSegmentLength)
  3759:         {
  3760:                 // Check to see if we have free space, and if so, if any of the data falls within the freespace
  3761:                 if(wFreeSpace)
  3762:                 {
  3763:                         // RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
  3764:                         if((lMissingBytes >= (LONG)0) && (wFreeSpace > (DWORD)lMissingBytes))
  3765:                                 bSegmentAcceptable = TRUE;
  3766:                         else
  3767:                         {
  3768:                                 // RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND
  3769:                                 if((lMissingBytes + (LONG)wSegmentLength > (LONG)0) && (lMissingBytes <= (LONG)(SHORT)(wFreeSpace - wSegmentLength)))
  3770:                                         bSegmentAcceptable = TRUE;
  3771:                         }
  3772:                         
  3773:                         if((lMissingBytes < (LONG)wFreeSpace) && ((SHORT)wMissingBytes + (SHORT)wSegmentLength > (SHORT)0))
  3774:                                 bSegmentAcceptable = TRUE;
  3775:                 }
  3776:                 // Segments with data are not acceptable if we have no free space
  3777:         }
  3778:         else
  3779:         {
  3780:                 // Zero length packets are acceptable if they fall within our free space window
  3781:                 // SEG.SEQ = RCV.NXT
  3782:                 if(lMissingBytes == 0)
  3783:                 {
  3784:                         bSegmentAcceptable = TRUE;
  3785:                 }
  3786:                 else
  3787:                 {
  3788:                         // RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
  3789:                         if((lMissingBytes >= (LONG)0) && (wFreeSpace > (DWORD)lMissingBytes))
  3790:                                 bSegmentAcceptable = TRUE;
  3791:                 }
  3792:         }
  3793:         
  3794:         if(!bSegmentAcceptable)
  3795:         {
  3796:                 // Unacceptable segment, drop it and respond appropriately
  3797:                 if(!(localHeaderFlags & RST)) 
  3798:                         SendTCP(ACK, SENDTCP_RESET_TIMERS);
  3799:                 return;
  3800:         }
  3801: 
  3802: 
  3803:         //
  3804:         // Second: check the RST bit
  3805:         //
  3806:         //
  3807:         // Fourth: check the SYN bit
  3808:         //
  3809:         // Note, that since the third step is not implemented, we can 
  3810:         // combine this second and fourth step into a single operation.
  3811:         if(localHeaderFlags & (RST | SYN))
  3812:         {
  3813:                 CloseSocket();
  3814:                 return;
  3815:         }
  3816: 
  3817:         //
  3818:         // Third: check the security and precedence
  3819:         //
  3820:         // Feature not supported.  Let's process this segment.
  3821: 
  3822:         //
  3823:         // Fifth: check the ACK bit
  3824:         //
  3825:         if(!(localHeaderFlags & ACK))
  3826:                 return;
  3827: 
  3828:         switch(MyTCBStub.smState)
  3829:         {
  3830:                 case TCP_SYN_RECEIVED:
  3831:                         if(localAckNumber != MyTCB.MySEQ)
  3832:                         {
  3833:                                 // Send a RST packet with SEQ = SEG.ACK, but retain our SEQ 
  3834:                                 // number for arivial of any other correct packets
  3835:                                 localSeqNumber = MyTCB.MySEQ;   // Save our original SEQ number
  3836:                                 MyTCB.MySEQ = localAckNumber;   // Set SEQ = SEG.ACK
  3837:                                 SendTCP(RST, SENDTCP_RESET_TIMERS);             // Send the RST
  3838:                                 MyTCB.MySEQ = localSeqNumber;   // Restore original SEQ number
  3839:                                 return;
  3840:                         }
  3841:                         MyTCBStub.smState = TCP_ESTABLISHED;
  3842:                         // No break
  3843: 
  3844:                 case TCP_ESTABLISHED:
  3845:                 case TCP_FIN_WAIT_1:
  3846:                 case TCP_FIN_WAIT_2:
  3847:                 case TCP_CLOSE_WAIT:
  3848:                 case TCP_CLOSING:
  3849:                         // Calculate what the highest possible SEQ number in our TX FIFO is
  3850:                         wTemp = MyTCBStub.txHead - MyTCB.txUnackedTail;
  3851:                         if((SHORT)wTemp < (SHORT)0)
  3852:                                 wTemp += MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart;
  3853:                         dwTemp = MyTCB.MySEQ + (DWORD)wTemp;
  3854: 
  3855:                         // Drop the packet if it ACKs something we haven't sent
  3856:                         if((LONG)(dwTemp - localAckNumber) < (LONG)0)
  3857:                         {
  3858:                                 SendTCP(ACK, 0);
  3859:                                 return;
  3860:                         }
  3861: 
  3862:                         // Throw away all ACKnowledged TX data:
  3863:                         // Calculate what the last acknowledged sequence number was (ignoring any FINs we sent)
  3864:                         dwTemp = MyTCB.MySEQ - (LONG)(SHORT)(MyTCB.txUnackedTail - MyTCBStub.txTail);
  3865:                         if(MyTCB.txUnackedTail < MyTCBStub.txTail)
  3866:                                 dwTemp -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart;
  3867:         
  3868:                         // Calcluate how many bytes were ACKed with this packet
  3869:                         dwTemp = localAckNumber - dwTemp;
  3870:                         if(((LONG)(dwTemp) > (LONG)0) && (dwTemp <= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart))
  3871:                         {
  3872:                                 MyTCB.flags.bRXNoneACKed1 = 0;
  3873:                                 MyTCB.flags.bRXNoneACKed2 = 0;
  3874:                                 MyTCBStub.Flags.bHalfFullFlush = FALSE;
  3875:         
  3876:                                 // Bytes ACKed, free up the TX FIFO space
  3877:                                 wTemp = MyTCBStub.txTail;
  3878:                                 MyTCBStub.txTail += dwTemp;
  3879:                                 if(MyTCB.txUnackedTail >= wTemp)
  3880:                                 {
  3881:                                         if(MyTCB.txUnackedTail < MyTCBStub.txTail)
  3882:                                         {
  3883:                                                 MyTCB.MySEQ += MyTCBStub.txTail - MyTCB.txUnackedTail;
  3884:                                                 MyTCB.txUnackedTail = MyTCBStub.txTail;
  3885:                                         }
  3886:                                 }
  3887:                                 else
  3888:                                 {
  3889:                                         wTemp = MyTCB.txUnackedTail + (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart);
  3890:                                         if(wTemp < MyTCBStub.txTail)
  3891:                                         {
  3892:                                                 MyTCB.MySEQ += MyTCBStub.txTail - wTemp;
  3893:                                                 MyTCB.txUnackedTail = MyTCBStub.txTail;
  3894:                                         }
  3895:                                 }
  3896:                                 if(MyTCBStub.txTail >= MyTCBStub.bufferRxStart)
  3897:                                         MyTCBStub.txTail -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart;
  3898:                                 if(MyTCB.txUnackedTail >= MyTCBStub.bufferRxStart)
  3899:                                         MyTCB.txUnackedTail -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart;
  3900:                         }
  3901:                         else
  3902:                         {
  3903:                                 // See if we have outstanding TX data that is waiting for an ACK
  3904:                                 if(MyTCBStub.txTail != MyTCB.txUnackedTail)
  3905:                                 {
  3906:                                         if(MyTCB.flags.bRXNoneACKed1)
  3907:                                         {
  3908:                                                 if(MyTCB.flags.bRXNoneACKed2)
  3909:                                                 {
  3910:                                                         // Set up to perform a fast retransmission
  3911:                                                         // Roll back unacknowledged TX tail pointer to cause retransmit to occur
  3912:                                                         MyTCB.MySEQ -= (LONG)(SHORT)(MyTCB.txUnackedTail - MyTCBStub.txTail);
  3913:                                                         if(MyTCB.txUnackedTail < MyTCBStub.txTail)
  3914:                                                                 MyTCB.MySEQ -= (LONG)(SHORT)(MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart);
  3915:                                                         MyTCB.txUnackedTail = MyTCBStub.txTail;
  3916:                                                         MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1;
  3917:                                                 }
  3918:                                                 MyTCB.flags.bRXNoneACKed2 = 1;
  3919:                                         }
  3920:                                         MyTCB.flags.bRXNoneACKed1 = 1;
  3921:                                 }
  3922:                         }
  3923: 
  3924:                         // No need to keep our retransmit timer going if we have nothing that needs ACKing anymore
  3925:                         if(MyTCBStub.txTail == MyTCBStub.txHead)
  3926:                         {
  3927:                                 // Make sure there isn't a "FIN byte in our TX FIFO"
  3928:                                 if(MyTCBStub.Flags.bTXFIN == 0u)
  3929:                                 {
  3930:                                         // Convert retransmission timer to keep-alive timer
  3931:                                         #if defined(TCP_KEEP_ALIVE_TIMEOUT)
  3932:                                                 MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT;
  3933:                                         #endif
  3934:                                         MyTCBStub.Flags.bTimerEnabled = 0;
  3935:                                 }
  3936:                                 else
  3937:                                 {
  3938:                                         // "Throw away" FIN byte from our TX FIFO if it has been ACKed
  3939:                                         if((MyTCB.MySEQ == localAckNumber) && MyTCB.flags.bFINSent)
  3940:                                         {
  3941:                                                 MyTCBStub.Flags.bTimerEnabled = 0;
  3942:                                                 MyTCBStub.Flags.bTXFIN = 0;
  3943:                                         }
  3944:                                 }
  3945:                         }
  3946: 
  3947:                         // The window size advirtised in this packet is adjusted to account 
  3948:                         // for any bytes that we have transmitted but haven't been ACKed yet 
  3949:                         // by this segment.
  3950:                         wNewWindow = h->Window - ((WORD)(MyTCB.MySEQ - localAckNumber));
  3951: 
  3952:                         // Update the local stored copy of the RemoteWindow.
  3953:                         // If previously we had a zero window, and now we don't, then 
  3954:                         // immediately send whatever was pending.
  3955:                         if((MyTCB.remoteWindow == 0u) && wNewWindow)
  3956:                                 MyTCBStub.Flags.bTXASAP = 1;
  3957:                         MyTCB.remoteWindow = wNewWindow;
  3958: 
  3959:                         // A couple of states must do all of the TCP_ESTABLISHED stuff, but also a little more
  3960:                         if(MyTCBStub.smState == TCP_FIN_WAIT_1)
  3961:                         {
  3962:                                 // Check to see if our FIN has been ACKnowledged
  3963:                                 if((MyTCB.MySEQ == localAckNumber) && MyTCB.flags.bFINSent)
  3964:                                 {
  3965:                                         // Reset our timer for forced closure if the remote node 
  3966:                                         // doesn't send us a FIN in a timely manner.
  3967:                                         MyTCBStub.eventTime = TickGet() + TCP_FIN_WAIT_2_TIMEOUT;
  3968:                                         MyTCBStub.Flags.bTimerEnabled = 1;
  3969:                                         MyTCBStub.smState = TCP_FIN_WAIT_2;
  3970:                                 }
  3971:                         }
  3972:                         else if(MyTCBStub.smState == TCP_FIN_WAIT_2)
  3973:                         {
  3974:                                 // RFC noncompliance:
  3975:                                 // The remote node should not keep sending us data 
  3976:                                 // indefinitely after we send a FIN to it.  
  3977:                                 // However, some bad stacks may still keep sending 
  3978:                                 // us data indefinitely after ACKing our FIN.  To 
  3979:                                 // prevent this from locking up our socket, let's 
  3980:                                 // send a RST right now and close forcefully on 
  3981:                                 // our side.
  3982:                                 if(!(localHeaderFlags & FIN))
  3983:                                 {
  3984:                                         MyTCB.MySEQ = localAckNumber;   // Set SEQ = SEG.ACK
  3985:                                         SendTCP(RST | ACK, 0);
  3986:                                         CloseSocket();
  3987:                                         return;
  3988:                                 }
  3989:                         }
  3990:                         else if(MyTCBStub.smState == TCP_CLOSING)
  3991:                         {
  3992:                                 // Check to see if our FIN has been ACKnowledged
  3993:                                 if(MyTCB.MySEQ == localAckNumber)
  3994:                                 {
  3995:                                         // RFC not recommended: We should be going to 
  3996:                                         // the TCP_TIME_WAIT state right here and 
  3997:                                         // starting a 2MSL timer, but since we have so 
  3998:                                         // few precious sockets, we can't afford to 
  3999:                                         // leave a socket waiting around doing nothing 
  4000:                                         // for a long time.  If the remote node does 
  4001:                                         // not recieve this ACK, it'll have to figure 
  4002:                                         // out on it's own that the connection is now 
  4003:                                         // closed.
  4004:                                         CloseSocket();
  4005:                                 }
  4006: 
  4007:                                 return;
  4008:                         }
  4009: 
  4010:                         break;
  4011: 
  4012:                 case TCP_LAST_ACK:
  4013:                         // Check to see if our FIN has been ACKnowledged
  4014:                         if(MyTCB.MySEQ == localAckNumber)
  4015:                                 CloseSocket();
  4016:                         return;
  4017: 
  4018: //              case TCP_TIME_WAIT:
  4019: //                      // Nothing is supposed to arrive here.  If it does, reset the quiet timer.
  4020: //                      SendTCP(ACK, SENDTCP_RESET_TIMERS);
  4021: //                      return;
  4022: 
  4023:                 default:
  4024:                         break;
  4025:         }
  4026: 
  4027:         //
  4028:         // Sixth: Check the URG bit
  4029:         //
  4030:         // Urgent packets are not supported in this stack, so we
  4031:         // will throw them away instead
  4032:         if(localHeaderFlags & URG)
  4033:                 return;
  4034: 
  4035:         //
  4036:         // Seventh: Process the segment text
  4037:         //
  4038:         // Throw data away if in a state that doesn't accept data
  4039:         if(MyTCBStub.smState == TCP_CLOSE_WAIT)
  4040:                 return;
  4041:         if(MyTCBStub.smState == TCP_CLOSING)
  4042:                 return;
  4043:         if(MyTCBStub.smState == TCP_LAST_ACK)
  4044:                 return;
  4045: //      if(MyTCBStub.smState == TCP_TIME_WAIT)
  4046: //              return;
  4047: 
  4048:         // Copy any valid segment data into our RX FIFO, if any
  4049:         if(len)
  4050:         {
  4051:                 // See if there are bytes we must skip
  4052:                 if((SHORT)wMissingBytes <= 0)
  4053:                 {
  4054:                         // Position packet read pointer to start of useful data area.
  4055:                         IPSetRxBuffer((h->DataOffset.Val << 2) - wMissingBytes);
  4056:                         len += wMissingBytes;           
  4057:         
  4058:                         // Truncate packets that would overflow our TCP RX FIFO
  4059:                         // and request a retransmit by sending a duplicate ACK
  4060:                         if(len > wFreeSpace)
  4061:                                 len = wFreeSpace;
  4062:         
  4063:                         MyTCB.RemoteSEQ += (DWORD)len;
  4064:                 
  4065:                         // Copy the application data from the packet into the socket RX FIFO
  4066:                         // See if we need a two part copy (spans bufferEnd->bufferRxStart)
  4067:                         if(MyTCBStub.rxHead + len > MyTCBStub.bufferEnd)
  4068:                         {
  4069:                                 wTemp = MyTCBStub.bufferEnd - MyTCBStub.rxHead + 1;
  4070:                                 TCPRAMCopy(MyTCBStub.rxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, wTemp);
  4071:                                 TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len - wTemp);
  4072:                                 MyTCBStub.rxHead = MyTCBStub.bufferRxStart + (len - wTemp);
  4073:                         }
  4074:                         else
  4075:                         {
  4076:                                 TCPRAMCopy(MyTCBStub.rxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len);
  4077:                                 MyTCBStub.rxHead += len;
  4078:                         }
  4079:                 
  4080:                         // See if we have a hole and other data waiting already in the RX FIFO
  4081:                         if(MyTCB.sHoleSize != -1)
  4082:                         {
  4083:                                 MyTCB.sHoleSize -= len;
  4084:                                 wTemp = MyTCB.wFutureDataSize + MyTCB.sHoleSize;
  4085:                 
  4086:                                 // See if we just closed up a hole, and if so, advance head pointer
  4087:                                 if((SHORT)wTemp < (SHORT)0)
  4088:                                 {
  4089:                                         MyTCB.sHoleSize = -1;
  4090:                                 }
  4091:                                 else if(MyTCB.sHoleSize <= 0)
  4092:                                 {
  4093:                                         MyTCB.RemoteSEQ += wTemp;
  4094:                                         MyTCBStub.rxHead += wTemp;
  4095:                                         if(MyTCBStub.rxHead > MyTCBStub.bufferEnd)
  4096:                                                 MyTCBStub.rxHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;                                                  
  4097:                                         MyTCB.sHoleSize = -1;
  4098:                                 }
  4099:                         }
  4100:                 } // This packet is out of order or we lost a packet, see if we can generate a hole to accomodate it
  4101:                 else if((SHORT)wMissingBytes > 0)
  4102:                 {
  4103:                         // Truncate packets that would overflow our TCP RX FIFO
  4104:                         if(len + wMissingBytes > wFreeSpace)
  4105:                                 len = wFreeSpace - wMissingBytes;
  4106:                 
  4107:                         // Position packet read pointer to start of useful data area.
  4108:                         IPSetRxBuffer(h->DataOffset.Val << 2);
  4109:         
  4110:                         // See if we need a two part copy (spans bufferEnd->bufferRxStart)
  4111:                         if(MyTCBStub.rxHead + wMissingBytes + len > MyTCBStub.bufferEnd)
  4112:                         {
  4113:                                 // Calculate number of data bytes to copy before wraparound
  4114:                                 wTemp = MyTCBStub.bufferEnd - MyTCBStub.rxHead + 1 - wMissingBytes;
  4115:                                 if((SHORT)wTemp >= 0)
  4116:                                 {
  4117:                                         TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, wTemp);
  4118:                                         TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len - wTemp);
  4119:                                 }
  4120:                                 else
  4121:                                 {
  4122:                                         TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes - (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1), MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len);
  4123:                                 }
  4124:                         }
  4125:                         else
  4126:                         {
  4127:                                 TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len);
  4128:                         }
  4129:                 
  4130:                         // Record the hole is here
  4131:                         if(MyTCB.sHoleSize == -1)
  4132:                         {
  4133:                                 MyTCB.sHoleSize = wMissingBytes;
  4134:                                 MyTCB.wFutureDataSize = len;
  4135:                         }
  4136:                         else
  4137:                         {
  4138:                                 // We already have a hole, see if we can shrink the hole 
  4139:                                 // or extend the future data size
  4140:                                 if(wMissingBytes < (WORD)MyTCB.sHoleSize)
  4141:                                 {
  4142:                                         if((wMissingBytes + len > (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize) || (wMissingBytes + len < (WORD)MyTCB.sHoleSize))
  4143:                                                 MyTCB.wFutureDataSize = len;
  4144:                                         else
  4145:                                                 MyTCB.wFutureDataSize = (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize - wMissingBytes;
  4146:                                         MyTCB.sHoleSize = wMissingBytes;
  4147:                                 }
  4148:                                 else if(wMissingBytes + len > (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize)
  4149:                                 {
  4150:                                         // Make sure that there isn't a second hole between 
  4151:                                         // our future data and this TCP segment's future data
  4152:                                         if(wMissingBytes <= (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize)
  4153:                                                 MyTCB.wFutureDataSize += wMissingBytes + len - (WORD)MyTCB.sHoleSize - MyTCB.wFutureDataSize;
  4154:                                 }
  4155:                                 
  4156:                         }
  4157:                 }
  4158:         }
  4159: 
  4160:         // Send back an ACK of the data (+SYN | FIN) we just received, 
  4161:         // if any.  To minimize bandwidth waste, we are implementing 
  4162:         // the delayed acknowledgement algorithm here, only sending 
  4163:         // back an immediate ACK if this is the second segment received.  
  4164:         // Otherwise, a 200ms timer will cause the ACK to be transmitted.
  4165:         if(wSegmentLength)
  4166:         {
  4167:                 // For non-established sockets, let's delete all data in 
  4168:                 // the RX buffer immediately after receiving it.  This is 
  4169:                 // not really how TCP was intended to operate since a 
  4170:                 // socket cannot receive any response after it sends a FIN,
  4171:                 // but our TCP application API doesn't readily accomodate
  4172:                 // receiving data after calling TCPDisconnect(), which 
  4173:                 // invalidates the application TCP handle.  By deleting all 
  4174:                 // data, we'll ensure that the RX window is nonzero and 
  4175:                 // the remote node will be able to send us a FIN response, 
  4176:                 // which needs an RX window of at least 1.
  4177:                 if(MyTCBStub.smState != TCP_ESTABLISHED)
  4178:                         MyTCBStub.rxTail = MyTCBStub.rxHead;
  4179: 
  4180:                 if(MyTCBStub.Flags.bOneSegmentReceived)
  4181:                 {
  4182:                         SendTCP(ACK, SENDTCP_RESET_TIMERS);
  4183:                         SyncTCB();
  4184:                         // bOneSegmentReceived is cleared in SendTCP(), so no need here
  4185:                 }
  4186:                 else
  4187:                 {
  4188:                         MyTCBStub.Flags.bOneSegmentReceived = TRUE;     
  4189:                 
  4190:                         // Do not send an ACK immediately back.  Instead, we will 
  4191:                         // perform delayed acknowledgements.  To do this, we will 
  4192:                         // just start a timer
  4193:                         if(!MyTCBStub.Flags.bDelayedACKTimerEnabled)
  4194:                         {
  4195:                                 MyTCBStub.Flags.bDelayedACKTimerEnabled = 1;
  4196:                                 MyTCBStub.OverlappedTimers.delayedACKTime = (WORD)TickGetDiv256() + (WORD)((TCP_DELAYED_ACK_TIMEOUT)>>8);
  4197:                         }
  4198:                 }
  4199:         }
  4200: 
  4201:         //
  4202:         // Eighth: check the FIN bit
  4203:         //
  4204:         if(localHeaderFlags & FIN)
  4205:         {
  4206:                 // Note: Since we don't have a good means of storing "FIN bytes" 
  4207:                 // in our TCP RX FIFO, we must ensure that FINs are processed 
  4208:                 // in-order.
  4209:                 if(MyTCB.RemoteSEQ + 1 == localSeqNumber + (DWORD)wSegmentLength)
  4210:                 {
  4211:                         // FINs are treated as one byte of data for ACK sequencing
  4212:                         MyTCB.RemoteSEQ++;
  4213:                         
  4214:                         switch(MyTCBStub.smState)
  4215:                         {
  4216:                                 case TCP_SYN_RECEIVED:
  4217:                                         // RFC in exact: Our API has no need for the user 
  4218:                                         // to explicitly close a socket that never really 
  4219:                                         // got opened fully in the first place, so just 
  4220:                                         // transmit a FIN automatically and jump to 
  4221:                                         // TCP_LAST_ACK
  4222:                                         MyTCBStub.smState = TCP_LAST_ACK;
  4223:                                         SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS);
  4224:                                         return;
  4225: 
  4226:                                 case TCP_ESTABLISHED:
  4227:                                         // Go to TCP_CLOSE_WAIT state
  4228:                                         MyTCBStub.smState = TCP_CLOSE_WAIT;
  4229:                                         
  4230:                                         // For legacy applications that don't call 
  4231:                                         // TCPDisconnect() as needed and expect the TCP/IP 
  4232:                                         // Stack to automatically close sockets when the 
  4233:                                         // remote node sends a FIN, let's start a timer so 
  4234:                                         // that we will eventually close the socket automatically
  4235:                                         MyTCBStub.OverlappedTimers.closeWaitTime = (WORD)TickGetDiv256() + (WORD)((TCP_CLOSE_WAIT_TIMEOUT)>>8);
  4236:                                         break;
  4237:         
  4238:                                 case TCP_FIN_WAIT_1:
  4239:                                         if(MyTCB.MySEQ == localAckNumber)
  4240:                                         {
  4241:                                                 // RFC not recommended: We should be going to 
  4242:                                                 // the TCP_TIME_WAIT state right here and 
  4243:                                                 // starting a 2MSL timer, but since we have so 
  4244:                                                 // few precious sockets, we can't afford to 
  4245:                                                 // leave a socket waiting around doing nothing 
  4246:                                                 // for a long time.  If the remote node does 
  4247:                                                 // not recieve this ACK, it'll have to figure 
  4248:                                                 // out on it's own that the connection is now 
  4249:                                                 // closed.
  4250:                                                 SendTCP(ACK, 0);
  4251:                                                 CloseSocket();
  4252:                                                 return;
  4253:                                         }
  4254:                                         else
  4255:                                         {
  4256:                                                 MyTCBStub.smState = TCP_CLOSING;
  4257:                                         }
  4258:                                         break;
  4259:         
  4260:                                 case TCP_FIN_WAIT_2:
  4261:                                         // RFC not recommended: We should be going to 
  4262:                                         // the TCP_TIME_WAIT state right here and 
  4263:                                         // starting a 2MSL timer, but since we have so 
  4264:                                         // few precious sockets, we can't afford to 
  4265:                                         // leave a socket waiting around doing nothing 
  4266:                                         // for a long time.  If the remote node does 
  4267:                                         // not recieve this ACK, it'll have to figure 
  4268:                                         // out on it's own that the connection is now 
  4269:                                         // closed.
  4270:                                         SendTCP(ACK, 0);
  4271:                                         CloseSocket();
  4272:                                         return;
  4273: 
  4274:                                 default:
  4275:                                         break;
  4276:                         }
  4277: 
  4278:                         // Acknowledge receipt of FIN
  4279:                         SendTCP(ACK, SENDTCP_RESET_TIMERS);
  4280:                 }
  4281:         }
  4282: }
  4283: 
  4284: /****************************************************************************
  4285:   Section:
  4286:         Buffer Management Functions
  4287:   ***************************************************************************/
  4288: 
  4289: /*****************************************************************************
  4290:   Function:
  4291:         BOOL TCPAdjustFIFOSize(TCP_SOCKET hTCP, WORD wMinRXSize, 
  4292:                                                         WORD wMinTXSize, BYTE vFlags)
  4293: 
  4294:   Summary:
  4295:         Adjusts the relative sizes of the RX and TX buffers.
  4296: 
  4297:   Description:
  4298:         This function can be used to adjust the relative sizes of the RX and
  4299:         TX FIFO depending on the immediate needs of an application.  Since a 
  4300:         larger FIFO can allow more data to be sent in a given packet, adjusting 
  4301:         the relative sizes on the fly can allow for optimal transmission speed 
  4302:         for one-sided application protocols.  For example, HTTP typically 
  4303:         begins by receiving large amounts of data from the client, then switches
  4304:         to serving large amounts of data back.  Adjusting the FIFO at these 
  4305:         points can increase performance substantially.  Once the FIFO is
  4306:         adjusted, a window update is sent.
  4307:         
  4308:         If neither or both of TCP_ADJUST_GIVE_REST_TO_TX and 
  4309:         TCP_ADJUST_GIVE_REST_TO_RX are set, the function distributes the
  4310:         remaining space equally.
  4311:         
  4312:         Received data can be preserved as long as the buffer is expanding and 
  4313:         has not wrapped.
  4314: 
  4315:   Precondition:
  4316:         TCP is initialized.
  4317: 
  4318:   Parameters:
  4319:         hTCP            - The socket to be adjusted
  4320:         wMinRXSize      - Minimum number of byte for the RX FIFO
  4321:         wMinTXSize      - Minimum number of bytes for the RX FIFO
  4322:         vFlags          - Any combination of TCP_ADJUST_GIVE_REST_TO_RX, 
  4323:                                   TCP_ADJUST_GIVE_REST_TO_TX, TCP_ADJUST_PRESERVE_RX.
  4324:                                   TCP_ADJUST_PRESERVE_TX is not currently supported.
  4325: 
  4326:   Return Values:
  4327:         TRUE - The FIFOs were adjusted successfully
  4328:         FALSE - Minimum RX, Minimum TX, or flags couldn't be accommodated and
  4329:                         therefore the socket was left unchanged.
  4330: 
  4331:   Side Effects:
  4332:         Any unacknowledged or untransmitted data in the TX FIFO is always
  4333:         deleted.
  4334: 
  4335:   Remarks:
  4336:         At least one byte must always be allocated to the RX buffer so that
  4337:         a FIN can be received.  The function automatically corrects for this.
  4338:   ***************************************************************************/
  4339: BOOL TCPAdjustFIFOSize(TCP_SOCKET hTCP, WORD wMinRXSize, WORD wMinTXSize, BYTE vFlags)
  4340: {
  4341:         PTR_BASE ptrTemp, ptrHead;
  4342:         WORD wTXAllocation;
  4343:         
  4344:         if(hTCP >= TCP_SOCKET_COUNT)
  4345:     {
  4346:         return FALSE;
  4347:     }
  4348:     
  4349:         // Load up info on this socket
  4350:         SyncTCBStub(hTCP);
  4351: 
  4352:         // RX has to be at least 1 byte to receive SYN and FIN bytes 
  4353:         // from the remote node, even if they aren't stored in the RX FIFO
  4354:         if(wMinRXSize == 0u)
  4355:                 wMinRXSize = 1;
  4356:                 
  4357:         // SSL connections need to be able to send or receive at least 
  4358:         // a full Alert record, MAC, and FIN
  4359:         #if defined(STACK_USE_SSL)
  4360:         if(TCPIsSSL(hTCP) && wMinRXSize < 25u)
  4361:                 wMinRXSize = 25;
  4362:         if(TCPIsSSL(hTCP) && wMinTXSize < 25u)
  4363:                 wMinTXSize = 25;
  4364:         #endif
  4365:         
  4366:         // Make sure space is available for minimums
  4367:         ptrTemp = MyTCBStub.bufferEnd - MyTCBStub.bufferTxStart - 1;
  4368:         if(wMinRXSize + wMinTXSize > ptrTemp)
  4369:                 return FALSE;
  4370: 
  4371:         SyncTCB();
  4372: 
  4373:         // Set both allocation flags if none set
  4374:         if(!(vFlags & (TCP_ADJUST_GIVE_REST_TO_TX | TCP_ADJUST_GIVE_REST_TO_RX)))
  4375:                 vFlags |= TCP_ADJUST_GIVE_REST_TO_TX | TCP_ADJUST_GIVE_REST_TO_RX;
  4376:                 
  4377: 
  4378:         // Allocate minimums
  4379:         wTXAllocation = wMinTXSize;
  4380:         ptrTemp -= wMinRXSize + wMinTXSize;
  4381: 
  4382:         // Allocate extra
  4383:         if(vFlags & TCP_ADJUST_GIVE_REST_TO_TX)
  4384:         {
  4385:                 if(vFlags & TCP_ADJUST_GIVE_REST_TO_RX)
  4386:                 {
  4387:                         // Do a 50%/50% split with any odd byte always going to the RX FIFO
  4388:                         wTXAllocation += ptrTemp>>1;
  4389:                 }
  4390:                 else
  4391:                 {
  4392:                         wTXAllocation += ptrTemp;
  4393:                 }
  4394:         }
  4395: 
  4396:         // Calculate new bufferRxStart pointer
  4397:         ptrTemp = MyTCBStub.bufferTxStart + wTXAllocation + 1;
  4398: 
  4399:         // Find the head pointer to use
  4400:         ptrHead = MyTCBStub.rxHead;
  4401:         #if defined(STACK_USE_SSL)
  4402:         if(TCPIsSSL(hTCP))
  4403:                 ptrHead = MyTCBStub.sslRxHead;
  4404:         #endif
  4405:         
  4406:         // If there's out-of-order data pending, adjust the head pointer to compensate
  4407:         if(MyTCB.sHoleSize != -1)
  4408:         {
  4409:                 ptrHead += MyTCB.sHoleSize + MyTCB.wFutureDataSize;
  4410:                 if(ptrHead > MyTCBStub.bufferEnd)
  4411:                         ptrHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;
  4412:         }
  4413: 
  4414:         // Determine if resizing will lose any RX data
  4415:         if(MyTCBStub.rxTail < ptrHead)
  4416:         {
  4417:                 if(ptrTemp > MyTCBStub.rxTail)
  4418:                 {
  4419:                         if(vFlags & TCP_ADJUST_PRESERVE_RX)
  4420:                                 return FALSE;
  4421:                         else
  4422:                         {
  4423:                                 MyTCBStub.rxTail = ptrTemp;
  4424:                                 MyTCBStub.rxHead = ptrTemp;
  4425: 
  4426:                                 #if defined(STACK_USE_SSL)
  4427:                                 MyTCBStub.sslRxHead = ptrTemp;
  4428:                                 #endif
  4429:                         }
  4430:                 }
  4431:         }
  4432:         else if(MyTCBStub.rxTail > ptrHead)
  4433:         {
  4434:                 if(ptrTemp > MyTCBStub.bufferRxStart)
  4435:                 {
  4436:                         if(vFlags & TCP_ADJUST_PRESERVE_RX)
  4437:                                 return FALSE;
  4438:                         else
  4439:                         {
  4440:                                 MyTCBStub.rxTail = ptrTemp;
  4441:                                 MyTCBStub.rxHead = ptrTemp;
  4442:                                 
  4443:                                 #if defined(STACK_USE_SSL)
  4444:                                 MyTCBStub.sslRxHead = ptrTemp;
  4445:                                 #endif
  4446:                         }
  4447:                 }
  4448:         }
  4449:         else
  4450:         {
  4451:                 // No data to preserve, but we may need to move 
  4452:                 // the pointers to stay in the RX space
  4453:                 MyTCBStub.rxTail = ptrTemp;
  4454:                 MyTCBStub.rxHead = ptrTemp;
  4455:                 
  4456:                 #if defined(STACK_USE_SSL)
  4457:                 MyTCBStub.sslRxHead = ptrTemp;
  4458:                 #endif
  4459:         }
  4460:         
  4461:         // If we need to preserve data that wrapped in the ring, we must copy
  4462:         if(ptrHead < MyTCBStub.rxTail && (vFlags & TCP_ADJUST_PRESERVE_RX))
  4463:         {
  4464:                 TCPRAMCopy(ptrTemp, MyTCBStub.vMemoryMedium, 
  4465:                         MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium,
  4466:                         ptrHead - MyTCBStub.bufferRxStart);
  4467: 
  4468:                 // Move the pointers if they were in front of the tail
  4469:                 #if defined(STACK_USE_SSL)
  4470:                 if(TCPIsSSL(hTCP) && MyTCBStub.sslRxHead < MyTCBStub.rxTail)
  4471:                         MyTCBStub.sslRxHead -= MyTCBStub.bufferRxStart - ptrTemp;
  4472:                 #endif
  4473:                 if(MyTCBStub.rxHead < MyTCBStub.rxTail)
  4474:                         MyTCBStub.rxHead -= MyTCBStub.bufferRxStart - ptrTemp;
  4475:         }
  4476:         
  4477:         // Move the RX buffer pointer - it's the one that divides the two
  4478:         MyTCBStub.bufferRxStart = ptrTemp;
  4479: 
  4480:         // Empty the TX buffer
  4481:         MyTCB.txUnackedTail = MyTCBStub.bufferTxStart;
  4482:         MyTCBStub.txTail = MyTCBStub.bufferTxStart;
  4483:         MyTCBStub.txHead = MyTCBStub.bufferTxStart;
  4484:         
  4485:         #if defined(STACK_USE_SSL)
  4486:         if(TCPIsSSL(hTCP))
  4487:                 MyTCBStub.sslTxHead = MyTCBStub.txHead + 5;
  4488:         #endif
  4489:         
  4490:         // Send a window update to notify remote node of change
  4491:         if(MyTCBStub.smState == TCP_ESTABLISHED)
  4492:                 SendTCP(ACK, SENDTCP_RESET_TIMERS);
  4493: 
  4494:         return TRUE;
  4495: 
  4496: }
  4497: 
  4498: /*****************************************************************************
  4499:   Function:
  4500:         static void TCPRAMCopy(PTR_BASE ptrDest, BYTE vDestType, PTR_BASE ptrSource, 
  4501:                                                         BYTE vSourceType, WORD wLength)
  4502: 
  4503:   Summary:
  4504:         Copies data to/from various memory mediums.
  4505: 
  4506:   Description:
  4507:         This function copies data between memory mediums (PIC RAM, SPI
  4508:         RAM, and Ethernet buffer RAM).
  4509: 
  4510:   Precondition:
  4511:         TCP is initialized.
  4512: 
  4513:   Parameters:
  4514:         ptrDest         - Address to write to
  4515:         vDestType       - Destination meidum (TCP_PIC_RAM, TCP_ETH_RAM, TCP_SPI_RAM)
  4516:         ptrSource       - Address to copy from
  4517:         vSourceType - Source medium (TCP_PIC_RAM, TCP_ETH_RAM, or TCP_SPI_RAM)
  4518:         wLength         - Number of bytes to copy
  4519: 
  4520:   Returns:
  4521:         None
  4522: 
  4523:   Remarks:
  4524:         Copying to a destination region that overlaps with the source address 
  4525:         is supported only if the destination start address is at a lower memory 
  4526:         address (closer to 0x0000) than the source pointer.  However, if they do 
  4527:         overlap there must be at least 4 bytes of non-overlap to ensure correct 
  4528:         results due to hardware DMA requirements.
  4529:   ***************************************************************************/
  4530: static void TCPRAMCopy(PTR_BASE ptrDest, BYTE vDestType, PTR_BASE ptrSource, BYTE vSourceType, WORD wLength)
  4531: {
  4532:         #if defined(SPIRAM_CS_TRIS)
  4533:         BYTE vBuffer[16];
  4534:         WORD w;
  4535:         #endif
  4536:                 
  4537:         switch(vSourceType)
  4538:         {
  4539:                 case TCP_PIC_RAM:
  4540:                         switch(vDestType)
  4541:                         {
  4542:                                 case TCP_PIC_RAM:
  4543:                                         memcpy((void*)(BYTE*)ptrDest, (void*)(BYTE*)ptrSource, wLength);
  4544:                                         break;
  4545:         
  4546:                                 case TCP_ETH_RAM:
  4547:                                         if(ptrDest!=(PTR_BASE)-1)
  4548:                                                 MACSetWritePtr(ptrDest);
  4549:                                         MACPutArray((BYTE*)ptrSource, wLength);
  4550:                                         break;
  4551:         
  4552:                                 #if defined(SPIRAM_CS_TRIS)
  4553:                                 case TCP_SPI_RAM:
  4554:                                         SPIRAMPutArray(ptrDest, (BYTE*)ptrSource, wLength);
  4555:                                         break;
  4556:                                 #endif
  4557:                         }
  4558:                         break;
  4559:         
  4560:                 case TCP_ETH_RAM:
  4561:                         switch(vDestType)
  4562:                         {
  4563:                                 case TCP_PIC_RAM:
  4564:                                         if(ptrSource!=(PTR_BASE)-1)
  4565:                                                 MACSetReadPtr(ptrSource);
  4566:                                         MACGetArray((BYTE*)ptrDest, wLength);
  4567:                                         break;
  4568:         
  4569:                                 case TCP_ETH_RAM:
  4570:                                         MACMemCopyAsync(ptrDest, ptrSource, wLength);
  4571:                                         while(!MACIsMemCopyDone());
  4572:                                         break;
  4573:         
  4574:                                 #if defined(SPIRAM_CS_TRIS)
  4575:                                 case TCP_SPI_RAM:
  4576:                                         if(ptrSource!=(PTR_BASE)-1)
  4577:                                                 MACSetReadPtr(ptrSource);
  4578:                                         w = sizeof(vBuffer);
  4579:                                         while(wLength)
  4580:                                         {
  4581:                                                 if(w > wLength)
  4582:                                                         w = wLength;
  4583:                                                 
  4584:                                                 // Read and write a chunk       
  4585:                                                 MACGetArray(vBuffer, w);
  4586:                                                 SPIRAMPutArray(ptrDest, vBuffer, w);
  4587:                                                 ptrDest += w;
  4588:                                                 wLength -= w;
  4589:                                         }
  4590:                                         break;
  4591:                                 #endif
  4592:                         }
  4593:                         break;
  4594:         
  4595:                 #if defined(SPIRAM_CS_TRIS)
  4596:                 case TCP_SPI_RAM:
  4597:                         switch(vDestType)
  4598:                         {
  4599:                                 case TCP_PIC_RAM:
  4600:                                         SPIRAMGetArray(ptrSource, (BYTE*)ptrDest, wLength);
  4601:                                         break;
  4602:         
  4603:                                 case TCP_ETH_RAM:
  4604:                                         if(ptrDest!=(PTR_BASE)-1)
  4605:                                                 MACSetWritePtr(ptrDest);
  4606:                                         w = sizeof(vBuffer);
  4607:                                         while(wLength)
  4608:                                         {
  4609:                                                 if(w > wLength)
  4610:                                                         w = wLength;
  4611:                                                 
  4612:                                                 // Read and write a chunk       
  4613:                                                 SPIRAMGetArray(ptrSource, vBuffer, w);
  4614:                                                 ptrSource += w;
  4615:                                                 MACPutArray(vBuffer, w);
  4616:                                                 wLength -= w;
  4617:                                         }
  4618:                                         break;
  4619:         
  4620:                                 case TCP_SPI_RAM:
  4621:                                         // Copy all of the data over in chunks
  4622:                                         w = sizeof(vBuffer);
  4623:                                         while(wLength)
  4624:                                         {
  4625:                                                 if(w > wLength)
  4626:                                                         w = wLength;
  4627:                                                         
  4628:                                                 SPIRAMGetArray(ptrSource, vBuffer, w);
  4629:                                                 SPIRAMPutArray(ptrDest, vBuffer, w);
  4630:                                                 ptrSource += w;
  4631:                                                 ptrDest += w;
  4632:                                                 wLength -= w;
  4633:                                         }
  4634:                                         break;
  4635:                         }
  4636:                         break;
  4637:                 #endif                  
  4638:         }
  4639: }
  4640: 
  4641: /*****************************************************************************
  4642:   Function:
  4643:         static void TCPRAMCopyROM(PTR_BASE wDest, BYTE wDestType, ROM BYTE* wSource, 
  4644:                                                                 WORD wLength)
  4645: 
  4646:   Summary:
  4647:         Copies data to/from various memory mediums.
  4648: 
  4649:   Description:
  4650:         This function copies data between memory mediums (PIC RAM, SPI
  4651:         RAM, and Ethernet buffer RAM).  This function is to be used when 
  4652:         copying from ROM.
  4653: 
  4654:   Precondition:
  4655:         TCP is initialized.
  4656: 
  4657:   Parameters:
  4658:         wDest           - Address to write to
  4659:         wDestType       - Destination meidum (TCP_PIC_RAM, TCP_ETH_RAM, TCP_SPI_RAM)
  4660:         wSource         - Address to copy from
  4661:         wLength         - Number of bytes to copy
  4662: 
  4663:   Returns:
  4664:         None
  4665: 
  4666:   Remarks:
  4667:         Copying to a destination region that overlaps with the source address 
  4668:         is supported only if the destination start address is at a lower memory 
  4669:         address (closer to 0x0000) than the source pointer.
  4670:         
  4671:         This function is aliased to TCPRAMCopy on non-PIC18 platforms.
  4672:   ***************************************************************************/
  4673: #if defined(__18CXX)
  4674: static void TCPRAMCopyROM(PTR_BASE wDest, BYTE wDestType, ROM BYTE* wSource, WORD wLength)
  4675: {
  4676:         BYTE vBuffer[16];
  4677:         WORD w;
  4678:         
  4679:         switch(wDestType)
  4680:         {
  4681:                 case TCP_PIC_RAM:
  4682:                         memcpypgm2ram((void*)(BYTE*)wDest, (ROM void*)wSource, wLength);
  4683:                         break;
  4684:         
  4685:                 case TCP_ETH_RAM:
  4686:                         if(wDest!=(PTR_BASE)-1)
  4687:                                 MACSetWritePtr(wDest);
  4688:                         w = sizeof(vBuffer);
  4689:                         while(wLength)
  4690:                         {
  4691:                                 if(w > wLength)
  4692:                                         w = wLength;
  4693:                                 
  4694:                                 // Read and write a chunk       
  4695:                                 memcpypgm2ram(vBuffer, (ROM void*)wSource, w);
  4696:                                 MACPutArray(vBuffer, w);
  4697:                                 wSource += w;
  4698:                                 wLength -= w;
  4699:                         }
  4700:                         break;
  4701:         
  4702:                 #if defined(SPIRAM_CS_TRIS)
  4703:                 case TCP_SPI_RAM:
  4704:                         w = sizeof(vBuffer);
  4705:                         while(wLength)
  4706:                         {
  4707:                                 if(w > wLength)
  4708:                                         w = wLength;
  4709:                                 
  4710:                                 // Read and write a chunk       
  4711:                                 memcpypgm2ram(vBuffer, (ROM void*)wSource, w);
  4712:                                 SPIRAMPutArray(wDest, vBuffer, w);
  4713:                                 wDest += w;
  4714:                                 wSource += w;
  4715:                                 wLength -= w;
  4716:                         }
  4717:                         break;
  4718:                 #endif
  4719:         }
  4720: }
  4721: #endif
  4722: 
  4723: /****************************************************************************
  4724:   Section:
  4725:         SSL Functions
  4726:   ***************************************************************************/
  4727: 
  4728: /*****************************************************************************
  4729:   Function:
  4730:         BOOL TCPStartSSLClient(TCP_SOCKET hTCP, BYTE* host)
  4731: 
  4732:   Summary:
  4733:         Begins an SSL client session.
  4734: 
  4735:   Description:
  4736:         This function escalates the current connection to an SSL secured 
  4737:         connection by initiating an SSL client handshake.
  4738: 
  4739:   Precondition:
  4740:         TCP is initialized and hTCP is already connected.
  4741: 
  4742:   Parameters:
  4743:         hTCP            - TCP connection to secure
  4744:         host            - Expected host name on certificate (currently ignored)
  4745: 
  4746:   Return Values:
  4747:         TRUE            - an SSL connection was initiated
  4748:         FALSE           - Insufficient SSL resources (stubs) were available
  4749: 
  4750:   Remarks:
  4751:         The host parameter is currently ignored and is not validated.
  4752:   ***************************************************************************/
  4753: #if defined(STACK_USE_SSL_CLIENT)
  4754: BOOL TCPStartSSLClient(TCP_SOCKET hTCP, BYTE* host)
  4755: {
  4756:         BYTE i;
  4757:         
  4758:         if(hTCP >= TCP_SOCKET_COUNT)
  4759:     {
  4760:         return FALSE;
  4761:     }
  4762:     
  4763:         SyncTCBStub(hTCP);
  4764:         
  4765:         // Make sure SSL is not established already
  4766:         if(MyTCBStub.sslStubID != SSL_INVALID_ID)
  4767:                 return FALSE;
  4768:         
  4769:         // Try to start the session
  4770:         MyTCBStub.sslStubID = SSLStartSession(hTCP, NULL, 0);
  4771:         
  4772:         // Make sure a session stub was obtained
  4773:         if(MyTCBStub.sslStubID == SSL_INVALID_ID)
  4774:                 return FALSE;
  4775: 
  4776:         // Mark connection as handshaking and return
  4777:         MyTCBStub.sslReqMessage = SSL_CLIENT_HELLO;
  4778:         MyTCBStub.sslRxHead = MyTCBStub.rxHead;
  4779:         MyTCBStub.sslTxHead = MyTCBStub.txHead;
  4780:         MyTCBStub.Flags.bSSLHandshaking = 1;
  4781:         for(i = 0; i < 5u; i++)
  4782:         {// Skip first 5 bytes in TX for the record header
  4783:                 if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart)
  4784:                         MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
  4785:         }
  4786:         return TRUE;
  4787: }
  4788: #endif // SSL Client
  4789: 
  4790: /*****************************************************************************
  4791:   Function:
  4792:         BOOL TCPStartSSLClientEx(TCP_SOCKET hTCP, BYTE* host, BYTE * buffer, BYTE suppDataType)
  4793: 
  4794:   Summary:
  4795:         Begins an SSL client session.
  4796: 
  4797:   Description:
  4798:         This function escalates the current connection to an SSL secured 
  4799:         connection by initiating an SSL client handshake.
  4800: 
  4801:   Precondition:
  4802:         TCP is initialized and hTCP is already connected.
  4803: 
  4804:   Parameters:
  4805:         hTCP                    - TCP connection to secure
  4806:         host                    - Expected host name on certificate (currently ignored)
  4807:         buffer          - Buffer for supplementary data return
  4808:         suppDataType    - Type of supplementary data to copy
  4809: 
  4810:   Return Values:
  4811:         TRUE            - an SSL connection was initiated
  4812:         FALSE           - Insufficient SSL resources (stubs) were available
  4813: 
  4814:   Remarks:
  4815:         The host parameter is currently ignored and is not validated.
  4816:   ***************************************************************************/
  4817: #if defined(STACK_USE_SSL_CLIENT)
  4818: BOOL TCPStartSSLClientEx(TCP_SOCKET hTCP, BYTE* host, void * buffer, BYTE suppDataType)
  4819: {
  4820:         BYTE i;
  4821:         
  4822:         if(hTCP >= TCP_SOCKET_COUNT)
  4823:     {
  4824:         return FALSE;
  4825:     }
  4826:     
  4827:         SyncTCBStub(hTCP);
  4828:         
  4829:         // Make sure SSL is not established already
  4830:         if(MyTCBStub.sslStubID != SSL_INVALID_ID)
  4831:                 return FALSE;
  4832:         
  4833:         // Try to start the session
  4834:         MyTCBStub.sslStubID = SSLStartSession(hTCP, buffer, suppDataType);
  4835:         
  4836:         // Make sure a session stub was obtained
  4837:         if(MyTCBStub.sslStubID == SSL_INVALID_ID)
  4838:                 return FALSE;
  4839: 
  4840:         // Mark connection as handshaking and return
  4841:         MyTCBStub.sslReqMessage = SSL_CLIENT_HELLO;
  4842:         MyTCBStub.sslRxHead = MyTCBStub.rxHead;
  4843:         MyTCBStub.sslTxHead = MyTCBStub.txHead;
  4844:         MyTCBStub.Flags.bSSLHandshaking = 1;
  4845:         for(i = 0; i < 5u; i++)
  4846:         {// Skip first 5 bytes in TX for the record header
  4847:                 if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart)
  4848:                         MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
  4849:         }
  4850:         return TRUE;
  4851: }
  4852: #endif // SSL Client
  4853: 
  4854: /*****************************************************************************
  4855:   Function:
  4856:         BOOL TCPStartSSLServer(TCP_SOCKET hTCP)
  4857: 
  4858:   Summary:
  4859:         Begins an SSL server session.
  4860: 
  4861:   Description:
  4862:         This function sets up an SSL server session when a new connection is
  4863:         established on an SSL port.
  4864: 
  4865:   Precondition:
  4866:         TCP is initialized and hTCP is already connected.
  4867: 
  4868:   Parameters:
  4869:         hTCP            - TCP connection to secure
  4870: 
  4871:   Return Values:
  4872:         TRUE            - an SSL connection was initiated
  4873:         FALSE           - Insufficient SSL resources (stubs) were available
  4874:   ***************************************************************************/
  4875: #if defined(STACK_USE_SSL_SERVER)
  4876: BOOL TCPStartSSLServer(TCP_SOCKET hTCP)
  4877: {
  4878:         BYTE i;
  4879:         
  4880:         if(hTCP >= TCP_SOCKET_COUNT)
  4881:     {
  4882:         return FALSE;
  4883:     }
  4884:     
  4885:         SyncTCBStub(hTCP);
  4886:         SyncTCB();
  4887:         
  4888:         // Make sure SSL is not established already
  4889:         if(MyTCBStub.sslStubID != SSL_INVALID_ID)
  4890:                 return TRUE;
  4891:         
  4892:         // Try to start the session
  4893:         MyTCBStub.sslStubID = SSLStartSession(hTCP, NULL, 0);
  4894:         
  4895:         // Make sure a session stub was obtained
  4896:         if(MyTCBStub.sslStubID == SSL_INVALID_ID)
  4897:                 return FALSE;
  4898: 
  4899:         // Swap the localPort and localSSLPort
  4900:         MyTCBStub.remoteHash.Val = MyTCB.localPort.Val;
  4901:         MyTCB.localPort.Val = MyTCB.localSSLPort.Val;
  4902:         MyTCB.localSSLPort.Val = MyTCBStub.remoteHash.Val;      
  4903: 
  4904:         // Mark connection as handshaking and return
  4905:         MyTCBStub.sslReqMessage = SSL_NO_MESSAGE;
  4906:         MyTCBStub.sslRxHead = MyTCBStub.rxHead;
  4907:         MyTCBStub.sslTxHead = MyTCBStub.txHead;
  4908:         MyTCBStub.Flags.bSSLHandshaking = 1;
  4909:         for(i = 0; i < 5u; i++)
  4910:         {// Skip first 5 bytes in TX for the record header
  4911:                 if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart)
  4912:                         MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
  4913:         }
  4914:         return TRUE;
  4915: }
  4916: #endif // SSL Client
  4917: 
  4918: /*****************************************************************************
  4919:   Function:
  4920:         BOOL TCPAddSSLListener(TCP_SOCKET hTCP, WORD port)
  4921: 
  4922:   Summary:
  4923:         Listens for SSL connection on a specific port.
  4924: 
  4925:   Description:
  4926:         This function adds an additional listening port to a TCP connection.  
  4927:         Connections made on this alternate port will be secured via SSL.
  4928: 
  4929:   Precondition:
  4930:         TCP is initialized and hTCP is listening.
  4931: 
  4932:   Parameters:
  4933:         hTCP            - TCP connection to secure
  4934:         port            - SSL port to listen on
  4935: 
  4936:   Return Values:
  4937:         TRUE            - SSL port was added.
  4938:         FALSE           - The socket was not a listening socket.
  4939:   ***************************************************************************/
  4940: #if defined(STACK_USE_SSL_SERVER)
  4941: BOOL TCPAddSSLListener(TCP_SOCKET hTCP, WORD port)
  4942: {
  4943:         if(hTCP >= TCP_SOCKET_COUNT)
  4944:     {
  4945:         return FALSE;
  4946:     }
  4947:     
  4948:         SyncTCBStub(hTCP);
  4949:         
  4950:         if(MyTCBStub.smState != TCP_LISTEN)
  4951:                 return FALSE;
  4952:         
  4953:         SyncTCB();
  4954:         
  4955:         MyTCB.localSSLPort.Val = port;
  4956:         MyTCBStub.sslTxHead = port;
  4957: 
  4958:         return TRUE;
  4959: }
  4960: #endif // SSL Server
  4961: 
  4962: /*****************************************************************************
  4963:   Function:
  4964:         BOOL TCPRequestSSLMessage(TCP_SOCKET hTCP, BYTE msg)
  4965: 
  4966:   Summary:
  4967:         Requests an SSL message to be transmitted.
  4968: 
  4969:   Description:
  4970:         This function is called to request that a specific SSL message be
  4971:         transmitted.  This message should only be called by the SSL module.
  4972:         
  4973:   Precondition:
  4974:         TCP is initialized.
  4975: 
  4976:   Parameters:
  4977:         hTCP            - TCP connection to use
  4978:         msg                     - One of the SSL_MESSAGE types to transmit.
  4979: 
  4980:   Return Values:
  4981:         TRUE            - The message was requested.
  4982:         FALSE           - Another message is already pending transmission.
  4983:   ***************************************************************************/
  4984: #if defined(STACK_USE_SSL)
  4985: BOOL TCPRequestSSLMessage(TCP_SOCKET hTCP, BYTE msg)
  4986: {
  4987:         if(hTCP >= TCP_SOCKET_COUNT)
  4988:     {
  4989:         return FALSE;
  4990:     }
  4991:     
  4992:         SyncTCBStub(hTCP);
  4993:         
  4994:         if(msg == SSL_NO_MESSAGE || MyTCBStub.sslReqMessage == SSL_NO_MESSAGE)
  4995:         {
  4996:                 MyTCBStub.sslReqMessage = msg;
  4997:                 return TRUE;
  4998:         }
  4999:         
  5000:         return FALSE;
  5001: }
  5002: #endif // SSL
  5003: 
  5004: /*****************************************************************************
  5005:   Function:
  5006:         BOOL TCPSSLIsHandshaking(TCP_SOCKET hTCP)
  5007: 
  5008:   Summary:
  5009:         Determines if an SSL session is still handshaking.
  5010: 
  5011:   Description:
  5012:         Call this function after calling TCPStartSSLClient until FALSE is
  5013:         returned.  Then your application may continue with its normal data
  5014:         transfer (which is now secured).
  5015:         
  5016:   Precondition:
  5017:         TCP is initialized and hTCP is connected.
  5018: 
  5019:   Parameters:
  5020:         hTCP            - TCP connection to check
  5021: 
  5022:   Return Values:
  5023:         TRUE            - SSL handshake is still progressing
  5024:         FALSE           - SSL handshake has completed
  5025:   ***************************************************************************/
  5026: #if defined(STACK_USE_SSL)
  5027: BOOL TCPSSLIsHandshaking(TCP_SOCKET hTCP)
  5028: {
  5029:         if(hTCP >= TCP_SOCKET_COUNT)
  5030:     {
  5031:         return FALSE;
  5032:     }
  5033:     
  5034:         SyncTCBStub(hTCP);
  5035:         return MyTCBStub.Flags.bSSLHandshaking; 
  5036: }
  5037: #endif // SSL
  5038: 
  5039: /*****************************************************************************
  5040:   Function:
  5041:         BOOL TCPIsSSL(TCP_SOCKET hTCP)
  5042: 
  5043:   Summary:
  5044:         Determines if a TCP connection is secured with SSL.
  5045: 
  5046:   Description:
  5047:         Call this function to determine whether or not a TCP connection is 
  5048:         secured with SSL.
  5049:         
  5050:   Precondition:
  5051:         TCP is initialized and hTCP is connected.
  5052: 
  5053:   Parameters:
  5054:         hTCP            - TCP connection to check
  5055: 
  5056:   Return Values:
  5057:         TRUE            - Connection is secured via SSL
  5058:         FALSE           - Connection is not secured
  5059:   ***************************************************************************/
  5060: #if defined(STACK_USE_SSL)
  5061: BOOL TCPIsSSL(TCP_SOCKET hTCP)
  5062: {
  5063:         if(hTCP >= TCP_SOCKET_COUNT)
  5064:     {
  5065:         return FALSE;
  5066:     }
  5067:     
  5068:         SyncTCBStub(hTCP);
  5069:         
  5070:         if(MyTCBStub.sslStubID == SSL_INVALID_ID)
  5071:                 return FALSE;
  5072:         
  5073:         return TRUE;
  5074: }
  5075: #endif // SSL
  5076: 
  5077: /*****************************************************************************
  5078:   Function:
  5079:         void TCPSSLHandshakeComplete(TCP_SOCKET hTCP)
  5080: 
  5081:   Summary:
  5082:         Clears the SSL handshake flag.
  5083: 
  5084:   Description:
  5085:         This function clears the flag indicating that an SSL handshake is
  5086:         complete.
  5087:         
  5088:   Precondition:
  5089:         TCP is initialized and hTCP is connected.
  5090: 
  5091:   Parameters:
  5092:         hTCP            - TCP connection to set
  5093: 
  5094:   Returns:
  5095:         None
  5096: 
  5097:   Remarks:
  5098:         This function should never be called by an application.  It is used 
  5099:         only by the SSL module itself.
  5100:   ***************************************************************************/
  5101: #if defined(STACK_USE_SSL)
  5102: void TCPSSLHandshakeComplete(TCP_SOCKET hTCP)
  5103: {
  5104:         if(hTCP >= TCP_SOCKET_COUNT)
  5105:     {
  5106:         return;
  5107:     }
  5108:     
  5109:         SyncTCBStub(hTCP);
  5110:         MyTCBStub.Flags.bSSLHandshaking = 0;
  5111: }
  5112: #endif // SSL
  5113: 
  5114: /*****************************************************************************
  5115:   Function:
  5116:         void TCPSSLDecryptMAC(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, WORD len)
  5117: 
  5118:   Summary:
  5119:         Decrypts and MACs data arriving via SSL.
  5120: 
  5121:   Description:
  5122:         This function decrypts data in the TCP buffer and calculates the MAC over
  5123:         the data.  All data is left in the exact same location in the TCP buffer.
  5124:         It is called to help process incoming SSL records.
  5125:         
  5126:   Precondition:
  5127:         TCP is initialized, hTCP is connected, and ctx's Sbox is loaded.
  5128: 
  5129:   Parameters:
  5130:         hTCP            - TCP connection to decrypt in
  5131:         ctx                     - ARCFOUR encryption context to use
  5132:         len             - Number of bytes to crypt
  5133:         inPlace         - TRUE to write back in place, FALSE to write at end of
  5134:                                         currently visible data.
  5135: 
  5136:   Returns:
  5137:         None
  5138: 
  5139:   Remarks:
  5140:         This function should never be called by an application.  It is used 
  5141:         only by the SSL module itself.
  5142:   ***************************************************************************/
  5143: #if defined(STACK_USE_SSL)
  5144: void TCPSSLDecryptMAC(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, WORD len)
  5145: {
  5146:         PTR_BASE wSrc, wDest, wBlockLen, wTemp;
  5147:         BYTE buffer[32];
  5148:         
  5149:         if(hTCP >= TCP_SOCKET_COUNT)
  5150:     {
  5151:         return;
  5152:     }
  5153:     
  5154:         // Set up the pointers
  5155:         SyncTCBStub(hTCP);
  5156:         wSrc = MyTCBStub.rxTail;
  5157:         wDest = wSrc;
  5158:         
  5159:         // Handle 32 bytes at a time
  5160:         while(len)
  5161:         {
  5162:                 // Determine how many bytes we can read
  5163:                 wBlockLen = sizeof(buffer);
  5164:                 if(wBlockLen > len) // Don't do more than we should
  5165:                         wBlockLen = len;
  5166:                 
  5167:                 // Read those bytes to a buffer
  5168:                 if(wSrc + wBlockLen > MyTCBStub.bufferEnd)
  5169:                 {// Two part read
  5170:                         wTemp = MyTCBStub.bufferEnd - wSrc + 1;
  5171:                         TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, wSrc, MyTCBStub.vMemoryMedium, wTemp);
  5172:                         TCPRAMCopy((PTR_BASE)buffer+wTemp, TCP_PIC_RAM, MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, wBlockLen - wTemp);
  5173:                         wSrc = MyTCBStub.bufferRxStart + wBlockLen - wTemp;
  5174:                 }
  5175:                 else
  5176:                 {
  5177:                         TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, wSrc, MyTCBStub.vMemoryMedium, wBlockLen);
  5178:                         wSrc += wBlockLen;
  5179:                 }
  5180:                 
  5181:                 // Decrypt and hash
  5182:                 ARCFOURCrypt(ctx, buffer, wBlockLen);
  5183:                 SSLMACAdd(buffer, wBlockLen);
  5184:                 
  5185:                 // Write decrypted bytes back
  5186:                 if(wDest + wBlockLen > MyTCBStub.bufferEnd)
  5187:                 {// Two part write
  5188:                         wTemp = MyTCBStub.bufferEnd - wDest + 1;
  5189:                         TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, wTemp);
  5190:                         TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer+wTemp, TCP_PIC_RAM, wBlockLen - wTemp);
  5191:                         wDest = MyTCBStub.bufferRxStart + wBlockLen - wTemp;
  5192:                 }
  5193:                 else
  5194:                 {
  5195:                         TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, wBlockLen);
  5196:                         wDest += wBlockLen;
  5197:                 }
  5198:                 
  5199:                 // Update the length remaining
  5200:                 len -= wBlockLen;
  5201:         }
  5202: }       
  5203: #endif // SSL
  5204: 
  5205: /*****************************************************************************
  5206:   Function:
  5207:         void TCPSSLInPlaceMACEncrypt(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, 
  5208:                                                                         BYTE* MACSecret, WORD len)
  5209: 
  5210:   Summary:
  5211:         Encrypts and MACs data in place in the TCP TX buffer.
  5212: 
  5213:   Description:
  5214:         This function encrypts data in the TCP buffer while calcuating a MAC.  
  5215:         When encryption is finished, the MAC is appended to the buffer and 
  5216:         the record will be ready to transmit.
  5217:         
  5218:   Precondition:
  5219:         TCP is initialized, hTCP is connected, and ctx's Sbox is loaded.
  5220: 
  5221:   Parameters:
  5222:         hTCP            - TCP connection to encrypt in
  5223:         ctx                     - ARCFOUR encryption context to use
  5224:         MACSecret       - MAC encryption secret to use
  5225:         len             - Number of bytes to crypt
  5226: 
  5227:   Returns:
  5228:         None
  5229: 
  5230:   Remarks:
  5231:         This function should never be called by an application.  It is used 
  5232:         only by the SSL module itself.
  5233:   ***************************************************************************/
  5234: #if defined(STACK_USE_SSL)
  5235: void TCPSSLInPlaceMACEncrypt(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, BYTE* MACSecret, WORD len)
  5236: {
  5237:         PTR_BASE pos;
  5238:         WORD blockLen;
  5239:         BYTE buffer[32];
  5240:         
  5241:         if(hTCP >= TCP_SOCKET_COUNT)
  5242:     {
  5243:         return;
  5244:     }
  5245:     
  5246:         // Set up the pointers
  5247:         SyncTCBStub(hTCP);
  5248:         pos = MyTCBStub.txHead;
  5249:         for(blockLen = 0; blockLen < 5u; blockLen++)
  5250:         {// Skips first 5 bytes for the header
  5251:                 if(++pos >= MyTCBStub.bufferRxStart)
  5252:                         pos = MyTCBStub.bufferTxStart;
  5253:         }
  5254:         
  5255:         // Handle 32 bytes at a time
  5256:         while(len)
  5257:         {
  5258:                 // Determine how many bytes we can read
  5259:                 blockLen = sizeof(buffer);
  5260:                 if(blockLen > len) // Don't do more than we should
  5261:                         blockLen = len;
  5262:                 if(blockLen > MyTCBStub.bufferRxStart - pos) // Don't pass the end
  5263:                         blockLen = MyTCBStub.bufferRxStart - pos;
  5264:                 
  5265:                 // Read those bytes to a buffer
  5266:                 TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, pos, MyTCBStub.vMemoryMedium, blockLen);
  5267:                 
  5268:                 // Hash and encrypt
  5269:                 SSLMACAdd(buffer, blockLen);
  5270:                 ARCFOURCrypt(ctx, buffer, blockLen);
  5271:                 
  5272:                 // Put them back
  5273:                 TCPRAMCopy(pos, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, blockLen);
  5274:                 
  5275:                 // Update the pointers
  5276:                 pos += blockLen;
  5277:                 len -= blockLen;
  5278:                 if(pos >= MyTCBStub.bufferRxStart)
  5279:                         pos = MyTCBStub.bufferTxStart;
  5280:         }
  5281:         
  5282:         // Calculate and add the MAC
  5283:         SSLMACCalc(MACSecret, buffer);
  5284:         ARCFOURCrypt(ctx, buffer, 16);
  5285: 
  5286:         // Write the MAC to the TX FIFO
  5287:         // Can't use TCPPutArray here because TCPIsPutReady() saves 16 bytes for the MAC
  5288:         // TCPPut* functions use this to prevent writing too much data.  Therefore, the
  5289:         // functionality is duplicated here.
  5290:         
  5291:         len = 16;
  5292:         blockLen = 0;
  5293:         // See if we need a two part put
  5294:         if(MyTCBStub.sslTxHead + len >= MyTCBStub.bufferRxStart)
  5295:         {
  5296:                 blockLen = MyTCBStub.bufferRxStart-MyTCBStub.sslTxHead;
  5297:                 TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, blockLen);
  5298:                 len -= blockLen;
  5299:                 MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
  5300:         }
  5301:         
  5302:         TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&buffer[blockLen], TCP_PIC_RAM, len);
  5303:         MyTCBStub.sslTxHead += len;
  5304: 
  5305: }       
  5306: #endif // SSL
  5307: 
  5308: /*****************************************************************************
  5309:   Function:
  5310:         void TCPSSLPutRecordHeader(TCP_SOCKET hTCP, BYTE* hdr, BOOL recDone)
  5311: 
  5312:   Summary:
  5313:         Writes an SSL record header and sends an SSL record.
  5314: 
  5315:   Description:
  5316:         This function writes an SSL record header to the pending TCP SSL data, 
  5317:         then indicates that the data is ready to be sent by moving the txHead
  5318:         pointer.
  5319:         
  5320:         If the record is complete, set recDone to TRUE.  The sslTxHead 
  5321:         pointer will be moved forward 5 bytes to leave space for a future 
  5322:         record header.  If the record is only partially sent, use FALSE and
  5323:         to leave the pointer where it is so that more data can be added
  5324:         to the record.  Partial records can only be used for the 
  5325:         SERVER_CERTIFICATE handshake message.
  5326:         
  5327:   Precondition:
  5328:         TCP is initialized, and hTCP is connected with an active SSL session.
  5329: 
  5330:   Parameters:
  5331:         hTCP            - TCP connection to write the header and transmit with
  5332:         hdr                     - Record header (5 bytes) to send or NULL to just 
  5333:                                   move the pointerctx
  5334:         recDone         - TRUE if the record is done, FALSE otherwise
  5335: 
  5336:   Returns:
  5337:         None
  5338: 
  5339:   Remarks:
  5340:         This function should never be called by an application.  It is used 
  5341:         only by the SSL module itself.
  5342:   ***************************************************************************/
  5343: #if defined(STACK_USE_SSL)
  5344: void TCPSSLPutRecordHeader(TCP_SOCKET hTCP, BYTE* hdr, BOOL recDone)
  5345: {
  5346:         BYTE i;
  5347:         
  5348:         if(hTCP >= TCP_SOCKET_COUNT)
  5349:     {
  5350:         return;
  5351:     }
  5352:     
  5353:         // Set up the pointers
  5354:         SyncTCBStub(hTCP);
  5355:         
  5356:         // Write the header if needed
  5357:         if(hdr)
  5358:         {// This is a new record, so insert the header
  5359:                 for(i = 0; i < 5u; i++)
  5360:                 {
  5361:                         TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)hdr+i, TCP_PIC_RAM, sizeof(BYTE));
  5362:                         if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart)
  5363:                                 MyTCBStub.txHead = MyTCBStub.bufferTxStart;
  5364:                 }
  5365:         }
  5366:         
  5367:         // Move the txHead pointer to indicate what data is ready
  5368:         // Also, flush just the header, then all the data.  This shotguns two 
  5369:         // packets down the line, therefore causing immediate ACKs by the 
  5370:         // remote node.  Reconnect handshakes are as much as 60% faster now.
  5371:         TCPFlush(hTCP);
  5372:         MyTCBStub.txHead = MyTCBStub.sslTxHead;
  5373:         TCPFlush(hTCP);
  5374:         
  5375:         // If this record is done, move the sslTxHead forward
  5376:         // to accomodate the next record header
  5377:         if(recDone)
  5378:         {
  5379:                 for(i = 0; i < 5u; i++)
  5380:                 {// Skip first 5 bytes in TX for the record header
  5381:                         if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart)
  5382:                                 MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
  5383:                 }
  5384:         }
  5385: }       
  5386: #endif // SSL
  5387: 
  5388: /*****************************************************************************
  5389:   Function:
  5390:         WORD TCPSSLGetPendingTxSize(TCP_SOCKET hTCP)
  5391: 
  5392:   Summary:
  5393:         Determines how many bytes are pending for a future SSL record.
  5394: 
  5395:   Description:
  5396:         This function determines how many bytes are pending for a future SSL
  5397:         record.
  5398:         
  5399:   Precondition:
  5400:         TCP is initialized, and hTCP is connected with an active SSL connection.
  5401: 
  5402:   Parameters:
  5403:         hTCP            - TCP connection to check
  5404: 
  5405:   Returns:
  5406:         None
  5407:   ***************************************************************************/
  5408: #if defined(STACK_USE_SSL)
  5409: WORD TCPSSLGetPendingTxSize(TCP_SOCKET hTCP)
  5410: {
  5411:         if(hTCP >= TCP_SOCKET_COUNT)
  5412:     {
  5413:         return 0;
  5414:     }
  5415:     
  5416:         SyncTCBStub(hTCP);
  5417: 
  5418:         // Non-SSL connections have no pending SSL data
  5419:         //if(MyTCBStub.sslStubID == SSL_INVALID_ID)
  5420:         //      return 0;
  5421:                         
  5422:         // Determine how many bytes are waiting to be written in this record
  5423:         if(MyTCBStub.sslTxHead > MyTCBStub.txHead)
  5424:                 return MyTCBStub.sslTxHead - MyTCBStub.txHead - 5;
  5425:         else
  5426:                 return (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.txHead - MyTCBStub.sslTxHead - 1) - 5;
  5427: }
  5428: #endif
  5429: 
  5430: 
  5431: /*****************************************************************************
  5432:   Function:
  5433:         void TCPSSLHandleIncoming(TCP_SOCKET hTCP)
  5434: 
  5435:   Summary:
  5436:         Hands newly arrive TCP data to the SSL module for processing.
  5437: 
  5438:   Description:
  5439:         This function processes incoming TCP data as an SSL record and 
  5440:         performs any necessary repositioning and decrypting.
  5441:         
  5442:   Precondition:
  5443:         TCP is initialized, and hTCP is connected with an active SSL session.
  5444: 
  5445:   Parameters:
  5446:         hTCP            - TCP connection to handle incoming data on
  5447: 
  5448:   Returns:
  5449:         None
  5450: 
  5451:   Remarks:
  5452:         This function should never be called by an application.  It is used 
  5453:         only by the SSL module itself.
  5454:   ***************************************************************************/
  5455: #if defined(STACK_USE_SSL)
  5456: void TCPSSLHandleIncoming(TCP_SOCKET hTCP)
  5457: {
  5458:         PTR_BASE prevRxTail, nextRxHead, startRxTail, wSrc, wDest;
  5459:         WORD wToMove, wLen, wSSLBytesThatPoofed, wDecryptedBytes;
  5460:         
  5461:         if(hTCP >= TCP_SOCKET_COUNT)
  5462:     {
  5463:         return;
  5464:     }
  5465:     
  5466:         // Sync the stub
  5467:         SyncTCBStub(hTCP);
  5468: 
  5469:         // If new data is waiting
  5470:         if(MyTCBStub.sslRxHead != MyTCBStub.rxHead)
  5471:         {
  5472:                 // Reconfigure pointers for SSL use
  5473:                 prevRxTail = MyTCBStub.rxTail;
  5474:                 nextRxHead = MyTCBStub.rxHead;
  5475:                 MyTCBStub.rxTail = MyTCBStub.rxHead;
  5476:                 MyTCBStub.rxHead = MyTCBStub.sslRxHead;
  5477:                 
  5478:                 do
  5479:                 {
  5480:                         startRxTail = MyTCBStub.rxTail;
  5481: 
  5482:                         // Handle incoming data.  This function performs deframing of the 
  5483:                         // SSL records, decryption, and MAC verification.
  5484:                         wSSLBytesThatPoofed = TCPIsGetReady(hTCP);
  5485:                         wDecryptedBytes = SSLRxRecord(hTCP, MyTCBStub.sslStubID);
  5486:                         wSSLBytesThatPoofed -= TCPIsGetReady(hTCP);
  5487: 
  5488:                         // Now need to move data to fill the SSL header/MAC/padding hole, 
  5489:                         // if there is one
  5490:                         if(wSSLBytesThatPoofed)
  5491:                         {       
  5492:                                 // Sync the TCP so we can see if there is a TCP hole
  5493:                                 SyncTCB();
  5494: 
  5495:                                 // Calculate how big the SSL hole is
  5496:                                 if(MyTCB.sHoleSize == -1)
  5497:                                 {// Just need to move pending SSL data
  5498:                                         wToMove = TCPIsGetReady(hTCP);
  5499:                                 }
  5500:                                 else
  5501:                                 {// A TCP hole exists, so move all data
  5502:                                         wToMove = TCPIsGetReady(hTCP) + MyTCB.sHoleSize + MyTCB.wFutureDataSize;
  5503:                                 }
  5504:                                 
  5505:                                 // Start with the destination as the startRxTail and source as current rxTail
  5506:                                 wDest = startRxTail;
  5507:                                 wSrc = MyTCBStub.rxTail;
  5508:                                 
  5509:                                 // If data exists between the end of the buffer and 
  5510:                                 // the destination, then move it forward
  5511:                                 if(wSrc > wDest)
  5512:                                 {
  5513:                                         wLen = MyTCBStub.bufferEnd - wSrc + 1;
  5514:                                         if(wLen > wToMove)
  5515:                                                 wLen = wToMove;
  5516:                                         TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, 
  5517:                                                            wSrc, MyTCBStub.vMemoryMedium, wLen);
  5518:                                         wDest += wLen;
  5519:                                         wSrc = MyTCBStub.bufferRxStart;
  5520:                                         wToMove -= wLen;
  5521:                                 }
  5522:                                 
  5523:                                 // If data remains to be moved, fill in to end of buffer
  5524:                                 if(wToMove)
  5525:                                 {
  5526:                                         wLen = MyTCBStub.bufferEnd - wDest + 1;
  5527:                                         if(wLen > wToMove)
  5528:                                                 wLen = wToMove;
  5529:                                         TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, 
  5530:                                                            wSrc, MyTCBStub.vMemoryMedium, wLen);
  5531:                                         wDest = MyTCBStub.bufferRxStart;
  5532:                                         wSrc += wLen;
  5533:                                         wToMove -= wLen;
  5534:                                 }
  5535:                                 
  5536:                                 // If data still remains, copy from from front + len to front
  5537:                                 if(wToMove)
  5538:                                 {
  5539:                                         TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium,
  5540:                                                            wSrc, MyTCBStub.vMemoryMedium, wToMove);
  5541:                                 }
  5542: 
  5543:                                 // Since bytes poofed, we need to move the head pointers 
  5544:                                 // backwards by an equal amount.
  5545:                                 MyTCBStub.rxHead -= wSSLBytesThatPoofed;
  5546:                                 if(MyTCBStub.rxHead < MyTCBStub.bufferRxStart)
  5547:                                         MyTCBStub.rxHead += MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;
  5548:                                 MyTCBStub.sslRxHead = MyTCBStub.rxHead;
  5549:                         }
  5550:                                 
  5551:                         // Move tail pointer forward by the number of decrypted bytes ready 
  5552:                         // for the application (but not poofed bytes)
  5553:                         MyTCBStub.rxTail = startRxTail + wDecryptedBytes;
  5554:                         if(MyTCBStub.rxTail > MyTCBStub.bufferEnd)
  5555:                                 MyTCBStub.rxTail -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;
  5556:                         nextRxHead += wDecryptedBytes;
  5557:                         
  5558:                         // Loop until SSLRxRecord() runs out of data and stops doing 
  5559:                         // anything
  5560:                 } while(wSSLBytesThatPoofed || (startRxTail != MyTCBStub.rxTail));
  5561: 
  5562:                 // Restore TCP buffer pointers to point to the decrypted application data 
  5563:                 // only
  5564:                 if(nextRxHead > MyTCBStub.bufferEnd)
  5565:                         nextRxHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;
  5566:                 MyTCBStub.rxTail = prevRxTail;
  5567:                 MyTCBStub.rxHead = nextRxHead;
  5568:         }
  5569: }       
  5570: #endif
  5571: 
  5572: 
  5573: #endif //#if defined(STACK_USE_TCP)
